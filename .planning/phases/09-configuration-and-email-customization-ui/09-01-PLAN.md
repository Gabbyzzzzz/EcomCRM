---
phase: 09-configuration-and-email-customization-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/automations/[id]/route.ts
  - src/components/automation-config-form.tsx
  - src/app/(dashboard)/automations/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can edit delay value/unit, trigger threshold, discount code, email subject, and body text on automation detail page"
    - "Clicking Save commits all changes to trigger_config and action_config JSON columns in the database"
    - "Clicking Cancel reverts all fields to the last saved state"
    - "A success toast confirms the save operation"
  artifacts:
    - path: "src/app/api/automations/[id]/route.ts"
      provides: "PATCH endpoint accepting full automation config"
      exports: ["PATCH"]
    - path: "src/components/automation-config-form.tsx"
      provides: "Controlled client component with editable fields, Save/Cancel, toast"
      min_lines: 80
    - path: "src/app/(dashboard)/automations/[id]/page.tsx"
      provides: "Detail page rendering AutomationConfigForm"
  key_links:
    - from: "src/components/automation-config-form.tsx"
      to: "/api/automations/[id]"
      via: "fetch PATCH on Save"
      pattern: "fetch.*api/automations.*method.*PATCH"
    - from: "src/app/api/automations/[id]/route.ts"
      to: "drizzle update automations"
      via: "db.update(automations).set()"
      pattern: "db\\.update\\(automations\\)"
---

<objective>
Build the automation configuration form with inline editable fields and a zod-validated PATCH API that persists all config changes to the database.

Purpose: Satisfies CFG-01 through CFG-05 — users can edit delay value/unit, trigger threshold, discount code, email subject, and body text, then Save or Cancel.
Output: Expanded PATCH API, AutomationConfigForm client component (controlled), updated detail page.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/app/api/automations/[id]/route.ts
@src/app/(dashboard)/automations/[id]/page.tsx
@src/lib/db/schema.ts
@src/lib/automation/presets.ts
@src/lib/db/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand PATCH API to accept full automation config</name>
  <files>src/app/api/automations/[id]/route.ts</files>
  <action>
Expand the existing PATCH endpoint at `src/app/api/automations/[id]/route.ts` to accept a full configuration update (not just `enabled`).

**Zod schema** — extend patchSchema to accept:
- `enabled` (boolean, optional) — existing field, keep backward-compatible
- `delayValue` (number, nullable, optional) — delay value in hours or days
- `delayUnit` (string, nullable, optional) — "hours" or "days"
- `triggerConfig` (object, optional) — free-form JSON, but validate it has expected shape per trigger type:
  - For `days_since_order`: `{ days: number, segments?: string[] }`
  - For `segment_change`: `{ toSegment: string }`
  - For others: pass-through (empty object OK)
- `actionConfig` (object, optional) — stores custom email content overrides:
  - `{ subject?: string, headline?: string, body?: string, ctaText?: string, discountCode?: string, alsoAddTag?: string }`
  Note: `alsoAddTag` is an existing field used by VIP preset — preserve it.

**Update logic:**
- If `enabled` is the only field → use existing `setAutomationEnabled` (keep backward compat for toggle)
- If other fields present → build a Drizzle `.update(automations).set({...})` call that only sets the provided fields
- Use `eq(automations.id, id)` as the where clause
- After update, SELECT the row back (write-then-read pattern from Phase 08-02) and return `{ ok: true, automation: { full row } }`

**Import env from `@/lib/env`** (not process.env directly) for shopId derivation.

Do NOT change the trigger_type, action_type, email_template_id, or name columns — those are preset identifiers and not user-editable.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors in the modified file. Manually inspect the file to confirm the zod schema covers all fields and the update logic handles partial updates correctly.
  </verify>
  <done>PATCH /api/automations/[id] accepts { enabled, delayValue, delayUnit, triggerConfig, actionConfig } with zod validation, persists to DB, and returns the updated row.</done>
</task>

<task type="auto">
  <name>Task 2: Build AutomationConfigForm as a controlled component and wire into detail page</name>
  <files>src/components/automation-config-form.tsx, src/app/(dashboard)/automations/[id]/page.tsx</files>
  <action>
**Create `src/components/automation-config-form.tsx`** — a `'use client'` CONTROLLED component.

IMPORTANT: This component must be a controlled component — it receives current field values and an onChange callback as props, NOT managing its own `useState`. This design enables Plan 09-02 to create a parent `AutomationDetailClient` wrapper that shares form state between this form and a live email preview panel.

Props interface:
```typescript
interface AutomationFormValues {
  delayValue: number | null
  delayUnit: string | null
  triggerConfig: Record<string, unknown> | null
  actionConfig: Record<string, unknown> | null
}

interface AutomationConfigFormProps {
  automationId: string
  triggerType: string
  values: AutomationFormValues
  onFieldChange: (field: keyof AutomationFormValues, value: unknown) => void
  onSave: () => Promise<void>
  onCancel: () => void
  isDirty: boolean
  isSaving: boolean
}
```

**Rendering logic:**
- Renders editable fields based on `values` prop (read from props, NOT local state)
- Calls `onFieldChange` when the user edits a field — the parent component owns the state
- Save button calls `onSave` — disabled when `!isDirty || isSaving`
- Cancel button calls `onCancel` — disabled when `!isDirty`

**Editable fields** (rendered conditionally based on triggerType):
1. **Delay Value + Unit** — number input + select (hours/days). Only show if triggerType is `first_order` or `cart_abandoned` (delays make sense for event-driven triggers). Reads from `values.delayValue` / `values.delayUnit`.
2. **Trigger Threshold (days)** — number input. Only show if triggerType is `days_since_order`. Reads/writes `values.triggerConfig.days` via `onFieldChange('triggerConfig', { ...values.triggerConfig, days: newVal })`.
3. **Discount Code** — text input. Always shown for email automations. Reads/writes `values.actionConfig.discountCode` via `onFieldChange('actionConfig', { ...values.actionConfig, discountCode: newVal })`.
4. **Email Subject** — text input. Always shown. Reads/writes `values.actionConfig.subject`. Placeholder shows default from SUBJECT_MAP based on emailTemplateId.
5. **Email Body Text** — textarea (3 rows). Always shown. Reads/writes `values.actionConfig.body`. Placeholder shows "Custom body text (leave blank to use template default)".

**Styling:** Use Tailwind classes consistent with existing card sections. Wrap in a `<div className="space-y-4">`. Use label + input pairs. Inputs use same className as send-test-email-button input (border-input, bg-background, ring focus styles).

**Update `src/app/(dashboard)/automations/[id]/page.tsx`:**
- For now (before Plan 09-02 adds the client wrapper), create a MINIMAL local client wrapper inside the detail page file (or import a small one) that:
  - Accepts `initialValues` from the server component
  - Uses `useState` to hold `AutomationFormValues` and derives `isDirty` by comparing to initial
  - Uses `useRef` for "last saved" snapshot (updated after successful Save)
  - Calls PATCH `/api/automations/${automationId}` on Save, shows `toast.success('Automation saved')` or `toast.error(message)`, and calls `router.refresh()` on success
  - Cancel resets state to "last saved" ref values
  - Passes `values`, `onFieldChange`, `onSave`, `onCancel`, `isDirty`, `isSaving` to `AutomationConfigForm`
- This wrapper will be EXTRACTED to `src/components/automation-detail-client.tsx` in Plan 09-02 — keep it simple and extractable
- Replace the static `<dl>` configuration section with AutomationConfigForm via the wrapper
- Keep the static display items that are NOT editable (trigger type name, action type, email template ID, last run) as read-only labels above or alongside the form
- Keep the Send Test Email and AI Copy Generator sections below the form unchanged
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Visit `/automations/{id}` in the browser — editable fields render with current values, Save/Cancel buttons appear, and editing a field enables Save.
  </verify>
  <done>AutomationConfigForm renders as a controlled component receiving values+onChange props; Save persists to DB via PATCH and shows success toast; Cancel reverts to last saved state. The component is ready for Plan 09-02 to lift state into a shared wrapper.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Visit any automation detail page — editable fields render with current DB values
3. Edit delay value, click Save — success toast appears, page refreshes with new value
4. Edit subject, click Cancel — field reverts to previous value
5. Verify in DB: `SELECT trigger_config, action_config FROM automations WHERE id = '...'` shows saved JSON
</verification>

<success_criteria>
- All 5 config fields (delay value/unit, trigger threshold, discount code, subject, body) are editable on the automation detail page
- AutomationConfigForm is a controlled component (values + onFieldChange props, no internal field state)
- Save commits changes to trigger_config and action_config JSON columns
- Cancel reverts all fields to last saved state
- Success toast confirms save
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-configuration-and-email-customization-ui/09-01-SUMMARY.md`
</output>
