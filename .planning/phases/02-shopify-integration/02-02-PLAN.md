---
phase: 02-shopify-integration
plan: "02"
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/shopify/sync.ts
  - src/lib/shopify/webhooks.ts
  - src/lib/shopify/queries.ts
  - src/app/api/webhooks/shopify/route.ts
  - src/app/api/sync/route.ts
  - src/inngest/functions.ts
  - src/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "Triggering a full sync starts a Shopify bulkOperationRunQuery and tracks it in sync_logs"
    - "Bulk operation completion webhook writes all customers and orders to DB with is_historical flag"
    - "Money values are stored as NUMERIC via decimal.js — never parseFloat"
    - "Webhook endpoint verifies HMAC before processing any payload"
    - "Duplicate webhook deliveries (same X-Shopify-Webhook-Id) are rejected — no double processing"
    - "Incremental webhooks (orders/create, orders/updated, customers/create, customers/update) upsert records with last-write-wins on shopify_updated_at"
    - "Selective merge on re-sync: Shopify fields overwritten, CRM fields (segment, rfm scores, lifecycle_stage) preserved"
  artifacts:
    - path: "src/lib/shopify/sync.ts"
      provides: "Bulk sync logic — start, poll/receive completion, process JSONL results"
      exports: ["startFullSync", "processFullSyncResults", "startIncrementalSync"]
    - path: "src/lib/shopify/webhooks.ts"
      provides: "HMAC verification and webhook processing"
      exports: ["verifyShopifyWebhook", "processWebhookPayload"]
    - path: "src/lib/shopify/queries.ts"
      provides: "GraphQL query strings for bulk operations and single-resource fetches"
      exports: ["BULK_CUSTOMERS_QUERY", "BULK_ORDERS_QUERY", "BULK_OPERATION_STATUS_QUERY"]
    - path: "src/app/api/webhooks/shopify/route.ts"
      provides: "POST handler for Shopify webhook ingestion"
      exports: ["POST"]
    - path: "src/app/api/sync/route.ts"
      provides: "POST handler to trigger sync, GET handler for sync status"
      exports: ["POST", "GET"]
    - path: "src/inngest/functions.ts"
      provides: "Inngest functions for async sync processing and webhook handling"
    - path: "src/lib/db/queries.ts"
      provides: "Reusable DB query functions for upserts and sync tracking"
      exports: ["upsertCustomer", "upsertOrder", "createSyncLog", "updateSyncLog", "checkWebhookIdempotency", "recordWebhookDelivery"]
  key_links:
    - from: "src/app/api/webhooks/shopify/route.ts"
      to: "src/lib/shopify/webhooks.ts"
      via: "verifyShopifyWebhook call before any processing"
      pattern: "verifyShopifyWebhook"
    - from: "src/app/api/webhooks/shopify/route.ts"
      to: "src/inngest/client.ts"
      via: "inngest.send to dispatch webhook events for Inngest processing"
      pattern: "inngest\\.send"
    - from: "src/lib/shopify/sync.ts"
      to: "src/lib/shopify/client.ts"
      via: "shopifyClient.query for GraphQL calls"
      pattern: "shopifyClient"
    - from: "src/lib/db/queries.ts"
      to: "src/lib/db/schema.ts"
      via: "imports table definitions for insert/update operations"
      pattern: "import.*from.*schema"
---

<objective>
Implement the full Shopify sync pipeline: bulk operation for initial data load, webhook endpoint with HMAC verification and idempotency, incremental sync handlers for real-time updates, and all Inngest function wiring.

Purpose: This is the core data pipeline — getting Shopify data into the database reliably, with no duplicates, no data loss, and proper handling of money values.

Output: Complete sync and webhook infrastructure, DB query functions, API routes, and Inngest functions.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-shopify-integration/02-01-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/db/index.ts
@src/lib/env.ts
@src/lib/shopify/client.ts
@src/lib/shopify/types.ts
@src/inngest/client.ts
@src/inngest/functions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB query functions and GraphQL query strings</name>
  <files>src/lib/db/queries.ts, src/lib/shopify/queries.ts</files>
  <action>
**Update `src/lib/db/queries.ts`** (currently empty placeholder — populate it):

Import `db` from `@/lib/db`, all tables from schema, `eq`, `and`, `sql` from `drizzle-orm`, and `Decimal` from `decimal.js`.

Implement these functions (all use the `db` singleton, no raw SQL — use Drizzle query builder):

1. **`upsertCustomer(shopId: string, data: {...})`**: Upsert on (shopId, shopifyId). Shopify fields (name, email, phone, tags, totalSpent, orderCount, avgOrderValue, firstOrderAt, lastOrderAt, shopifyUpdatedAt) are always overwritten. CRM fields (rfmR, rfmF, rfmM, segment, lifecycleStage) are preserved on conflict — use `onConflictDoUpdate` with `target: [customers.shopId, customers.shopifyId]` and only set Shopify-owned columns. Money values: convert using `new Decimal(amount).toString()` before storing — NEVER parseFloat. The `shopifyUpdatedAt` field enables last-write-wins: only update if incoming `updatedAt > existing shopifyUpdatedAt` (add a WHERE clause on the onConflict). Return the upserted row.

   NOTE: The schema currently has separate indexes on shopId and shopifyId. For the upsert to work, you need a UNIQUE constraint on (shopId, shopifyId). Add a `.unique()` composite on these columns in schema.ts if not already present, OR use `sql` to do an INSERT ... ON CONFLICT (shop_id, shopify_id) DO UPDATE via raw SQL wrapped in Drizzle's `sql` tagged template. Prefer the raw SQL approach to avoid a schema migration just for the unique constraint — but document clearly that a proper unique index should be added in the migration.

   Actually — the better approach: Add a unique composite index in schema.ts (`uniqueIndex('customers_shop_shopify_unique').on(table.shopId, table.shopifyId)`) and it will be picked up in the next migration generate. Do this in this task since we will re-run drizzle-kit generate.

2. **`upsertOrder(shopId: string, data: {...}, isHistorical: boolean)`**: Similar upsert on (shopId, shopifyId). Set isHistorical flag. Money: `new Decimal(totalPrice).toString()`. Add unique composite index on orders table too: `uniqueIndex('orders_shop_shopify_unique').on(table.shopId, table.shopifyId)`.

3. **`createSyncLog(shopId: string, type: 'full' | 'incremental')`**: Insert into syncLogs with status 'pending', return the created row.

4. **`updateSyncLog(id: string, updates: Partial<{status, completedAt, customersCount, ordersCount, errorMessage, cursor, bulkOperationId}>)`**: Update syncLogs by id.

5. **`checkWebhookIdempotency(shopId: string, webhookId: string)`**: Check if webhookId already exists in webhookDeliveries for this shop. Return boolean (true = already processed, skip).

6. **`recordWebhookDelivery(shopId: string, webhookId: string, topic: string, status?: string)`**: Insert into webhookDeliveries. On conflict (shopId, webhookId) do nothing.

7. **`getLatestSyncLog(shopId: string)`**: Get most recent sync_log for this shop, ordered by startedAt desc, limit 1.

8. **`softDeleteCustomer(shopId: string, shopifyId: string)`**: Set deletedAt = now() on the customer row.

After adding unique composite indexes to schema.ts for customers and orders, run `npx drizzle-kit generate` to create a new migration that includes both the unique indexes AND the columns/tables from Task 1 of plan 02-01 (if not yet migrated). Check the generated SQL is correct.

**Create `src/lib/shopify/queries.ts`:**

GraphQL query strings as exported constants:

1. **`BULK_CUSTOMERS_QUERY`**: bulkOperationRunQuery mutation that fetches all customers with fields: id, firstName, lastName, email, phone, ordersCount, totalSpentV2 { amount, currencyCode }, tags, createdAt, updatedAt. Use the `query` argument inside bulkOperationRunQuery.

2. **`BULK_ORDERS_QUERY`**: bulkOperationRunQuery mutation for orders: id, name, totalPriceSet { shopMoney { amount, currencyCode } }, customer { id }, lineItems(first: 50) { edges { node { title, quantity, variant { price { amount } } } } }, financialStatus, createdAt, updatedAt.

3. **`BULK_OPERATION_STATUS_QUERY`**: Query `currentBulkOperation { id, status, errorCode, objectCount, url, partialDataUrl }`.

4. **`SINGLE_CUSTOMER_QUERY`**: Query to fetch a single customer by GID — same fields as bulk.

5. **`SINGLE_ORDER_QUERY`**: Query to fetch a single order by GID — same fields as bulk.
  </action>
  <verify>Run `npx drizzle-kit generate` to confirm migration generates. TypeScript compilation passes for queries.ts and shopify/queries.ts files.</verify>
  <done>DB query functions handle upserts with selective merge, idempotency checks, sync log tracking. GraphQL query strings ready for use. Unique composite indexes added to schema. Migration generated.</done>
</task>

<task type="auto">
  <name>Task 2: Bulk sync, webhook endpoint, incremental handlers, and Inngest wiring</name>
  <files>src/lib/shopify/sync.ts, src/lib/shopify/webhooks.ts, src/app/api/webhooks/shopify/route.ts, src/app/api/sync/route.ts, src/inngest/functions.ts</files>
  <action>
**Create `src/lib/shopify/sync.ts`:**

Import shopifyClient, types, queries (DB + GraphQL), Decimal from decimal.js.

1. **`startFullSync(shopId: string)`**:
   - Create a syncLog entry (status: 'running')
   - Run BULK_CUSTOMERS_QUERY via shopifyClient.query
   - Store the bulkOperationId in syncLog
   - Return { syncLogId, bulkOperationId }
   - The completion will be handled by the bulk_operations/finish webhook (SHOP-03 — async, not polling)

2. **`processFullSyncResults(syncLogId: string, shopId: string, jsonlUrl: string, syncStartedAt: Date)`**:
   - Fetch the JSONL file from the URL Shopify provides
   - Parse line by line (each line is a JSON object — customer or order)
   - For customers: call upsertCustomer with Shopify fields
   - For orders: call upsertOrder with isHistorical = true if order.createdAt < syncStartedAt (per user decision: cutover timestamp approach)
   - Money values: always use Decimal, never parseFloat (SHOP-07)
   - Track counts (customers processed, orders processed)
   - Update syncLog with final counts and status 'completed'
   - On error: update syncLog with error message and status 'failed', store cursor for resume

3. **`startIncrementalSync(shopId: string)`**:
   - Get latest successful sync's completedAt timestamp
   - Use GraphQL to fetch customers/orders updated since that timestamp using `updated_at:>` filter
   - Upsert each record using the selective merge functions
   - Create and complete a syncLog entry with type 'incremental'

**Create `src/lib/shopify/webhooks.ts`:**

1. **`verifyShopifyWebhook(rawBody: string, hmacHeader: string): boolean`**:
   - Import env for SHOPIFY_WEBHOOK_SECRET
   - Compute HMAC-SHA256 of rawBody using the secret
   - Compare with hmacHeader using timing-safe comparison (crypto.timingSafeEqual)
   - Return true/false — SHOP-04 requires verification BEFORE any parsing
   - Use Node.js `crypto` module (available in Next.js API routes)

2. **`parseWebhookTopic(headers: Headers): string`**:
   - Extract `X-Shopify-Topic` header
   - Return the topic string (e.g., 'orders/create')

3. **`extractWebhookId(headers: Headers): string`**:
   - Extract `X-Shopify-Webhook-Id` header for idempotency

**Create `src/app/api/webhooks/shopify/route.ts`:**

Export async function POST(request: Request):
1. Read raw body with `await request.text()` — MUST be before any JSON parsing (SHOP-04)
2. Get HMAC from `X-Shopify-Hmac-Sha256` header
3. Call verifyShopifyWebhook — if false, log warning and return 401
4. Extract webhook ID and topic from headers
5. Check idempotency: call checkWebhookIdempotency — if already processed, return 200 (skip)
6. Record webhook delivery
7. Parse the raw body as JSON
8. Dispatch to Inngest: `await inngest.send({ name: 'shopify/webhook.received', data: { shopId, topic, payload, webhookId } })`
9. Return 200 immediately (processing happens async in Inngest)

The shopId should be derived from env.SHOPIFY_STORE_URL (extract the store name) or hardcoded as a constant since this is a single-store Custom App.

**Create `src/app/api/sync/route.ts`:**

Export POST handler (triggers sync):
1. Validate request with zod (optional `force` boolean param)
2. If force=true or no data exists: call startFullSync
3. Else: call startIncrementalSync
4. Return { syncLogId, status: 'started' }

Export GET handler (returns sync status):
1. Call getLatestSyncLog
2. Return the sync log entry (status, counts, timestamps)

**Update `src/inngest/functions.ts`:**

Replace empty array with actual Inngest functions:

1. **`processShopifyWebhook`**: `inngest.createFunction({ id: 'process-shopify-webhook', retries: 4 }, { event: 'shopify/webhook.received' }, async ({ event, step }) => {...})`
   - Extract topic and payload from event.data
   - Switch on topic:
     - 'orders/create': upsertOrder with isHistorical=false
     - 'orders/updated': upsertOrder with isHistorical=false, last-write-wins on shopify_updated_at
     - 'customers/create': upsertCustomer
     - 'customers/update': upsertCustomer with last-write-wins
     - 'customers/delete': softDeleteCustomer
     - 'bulk_operations/finish': look up syncLog by bulkOperationId, call processFullSyncResults
   - On final failure (all retries exhausted): update webhook_deliveries status to 'dead_letter'

2. **`scheduledSync`**: `inngest.createFunction({ id: 'scheduled-sync', retries: 2 }, { cron: '0 */6 * * *' }, async ({ step }) => {...})`
   - Every 6 hours, run startIncrementalSync
   - Ensures data stays fresh even if webhooks are missed

3. **`processFullSyncCompletion`**: `inngest.createFunction({ id: 'process-full-sync-completion', retries: 3 }, { event: 'shopify/bulk-operation.completed' }, async ({ event, step }) => {...})`
   - Receives bulk operation completion event
   - Fetches JSONL URL from Shopify
   - Calls processFullSyncResults

Import all functions from the modules and register them in the exported `functions` array.
  </action>
  <verify>TypeScript compilation passes for all new files. Check that: (1) webhook route reads raw body before parsing, (2) HMAC verification uses timing-safe comparison, (3) money values use Decimal not parseFloat, (4) upsertCustomer preserves CRM fields, (5) Inngest functions are registered in the array.</verify>
  <done>Full sync pipeline works: bulk operation start -> async completion -> JSONL processing -> DB writes. Webhook endpoint verifies HMAC, deduplicates on webhook ID, dispatches to Inngest. Incremental handlers upsert with selective merge and last-write-wins. Scheduled sync runs every 6 hours.</done>
</task>

</tasks>

<verification>
- All TypeScript files compile without errors (excluding expected env.ts warnings)
- Webhook route reads body with request.text() BEFORE any JSON.parse
- HMAC uses crypto.timingSafeEqual for timing-safe comparison
- All money fields go through Decimal (grep for parseFloat should find nothing in shopify/ or db/ directories)
- Inngest functions array is populated (no longer empty)
- upsertCustomer only overwrites Shopify fields, preserves rfmR/rfmF/rfmM/segment/lifecycleStage
- webhookDeliveries checked before processing (idempotency)
</verification>

<success_criteria>
- SHOP-01: Cost-based throttling in client (from 02-01)
- SHOP-02: bulkOperationRunQuery starts full sync, JSONL results processed into DB
- SHOP-03: Async bulk operation via webhook completion (not polling)
- SHOP-04: HMAC verification before any payload parsing
- SHOP-05: Webhook idempotency via webhookDeliveries table
- SHOP-06: Incremental handlers for orders/create, orders/updated, customers/create, customers/update
- SHOP-07: All money as NUMERIC via Decimal — no parseFloat
- SHOP-08: is_historical flag on bulk-synced orders based on cutover timestamp
</success_criteria>

<output>
After completion, create `.planning/phases/02-shopify-integration/02-02-SUMMARY.md`
</output>
