---
phase: 02-shopify-integration
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/shopify/client.ts
  - src/lib/shopify/types.ts
  - drizzle/0001_shopify_sync.sql
autonomous: true

must_haves:
  truths:
    - "Shopify GraphQL client can make authenticated requests to the store's Admin API"
    - "Client automatically backs off when API cost budget is low — no 429 errors"
    - "Schema has sync_logs, webhook_deliveries tables and new columns (is_historical, deleted_at, shopify_updated_at) on existing tables"
    - "Migration SQL is generated and ready to apply"
  artifacts:
    - path: "src/lib/shopify/client.ts"
      provides: "Authenticated GraphQL client with cost-based throttling"
      exports: ["shopifyClient", "shopifyGraphQL"]
    - path: "src/lib/shopify/types.ts"
      provides: "TypeScript types for Shopify GraphQL responses"
      exports: ["ShopifyCustomer", "ShopifyOrder", "ShopifyBulkOperation", "GraphQLResponse", "GraphQLCostExtension"]
    - path: "src/lib/db/schema.ts"
      provides: "Updated schema with sync_logs, webhook_deliveries, and new columns"
      contains: "syncLogs"
    - path: "drizzle/0001_shopify_sync.sql"
      provides: "Migration SQL for schema changes"
  key_links:
    - from: "src/lib/shopify/client.ts"
      to: "src/lib/env.ts"
      via: "imports env for SHOPIFY_STORE_URL and SHOPIFY_ACCESS_TOKEN"
      pattern: "import.*env.*from.*@/lib/env"
---

<objective>
Create the Shopify GraphQL client with cost-based rate limiting and extend the database schema with sync tracking tables and columns needed for the full sync pipeline.

Purpose: Everything in Phase 2 depends on (a) being able to talk to Shopify's Admin API without hitting rate limits, and (b) having the right DB structure to track syncs, deduplicate webhooks, and flag historical data.

Output: `src/lib/shopify/client.ts` (GraphQL client), `src/lib/shopify/types.ts` (type definitions), updated `src/lib/db/schema.ts`, and generated migration SQL.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/db/schema.ts
@src/lib/db/index.ts
@src/lib/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DB schema with sync tracking tables and columns</name>
  <files>src/lib/db/schema.ts</files>
  <action>
Add the following to the existing schema.ts (do NOT rewrite existing tables/enums — ADD to them):

**New enum:**
- `syncStatusEnum`: pgEnum('sync_status', ['pending', 'running', 'completed', 'failed', 'cancelled'])

**New columns on existing `orders` table:**
- `isHistorical`: boolean('is_historical').default(false).notNull() — flags orders loaded during initial bulk sync
- `shopifyCreatedAt`: timestamp('shopify_created_at', { withTimezone: true }) — Shopify's original created_at

**New columns on existing `customers` table:**
- `deletedAt`: timestamp('deleted_at', { withTimezone: true }) — soft-delete flag for Shopify-deleted customers
- `shopifyUpdatedAt`: timestamp('shopify_updated_at', { withTimezone: true }) — for last-write-wins upsert on out-of-order webhooks

**New table: `syncLogs`** (tracks each sync run):
- `id`: uuid PK defaultRandom
- `shopId`: varchar(255) notNull
- `type`: varchar(50) notNull — 'full' | 'incremental'
- `status`: syncStatusEnum notNull
- `startedAt`: timestamp(withTimezone) notNull defaultNow
- `completedAt`: timestamp(withTimezone)
- `customersCount`: integer default(0)
- `ordersCount`: integer default(0)
- `errorMessage`: text
- `cursor`: text — checkpoint cursor for resume on failure
- `bulkOperationId`: varchar(255) — Shopify bulk operation GID for async tracking
- Indexes: shopId, status, startedAt

**New table: `webhookDeliveries`** (idempotency dedup for SHOP-05):
- `id`: uuid PK defaultRandom
- `shopId`: varchar(255) notNull
- `webhookId`: varchar(255) notNull — X-Shopify-Webhook-Id header value
- `topic`: varchar(100) notNull — e.g. 'orders/create'
- `processedAt`: timestamp(withTimezone) notNull defaultNow
- `status`: varchar(50) notNull default('processed') — 'processed' | 'failed' | 'dead_letter'
- `errorMessage`: text
- `retryCount`: integer default(0)
- Indexes: shopId, unique index on (shopId, webhookId), topic

Export all new tables and enums with `export const` at module top level (critical — drizzle-kit skips non-exported items).
  </action>
  <verify>Run `npx drizzle-kit generate` — it should produce a new migration file (0001_*.sql) with ALTER TABLE statements for new columns and CREATE TABLE for new tables. Check the SQL file contains: is_historical, deleted_at, shopify_updated_at, sync_logs, webhook_deliveries.</verify>
  <done>Schema has syncLogs, webhookDeliveries tables, orders.isHistorical, customers.deletedAt, customers.shopifyUpdatedAt columns. Migration SQL generated successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Shopify GraphQL client with cost-based rate limiting</name>
  <files>src/lib/shopify/client.ts, src/lib/shopify/types.ts</files>
  <action>
**Create `src/lib/shopify/types.ts`:**

Define TypeScript types for Shopify Admin GraphQL API responses:
- `GraphQLCostExtension`: `{ requestedQueryCost: number; actualQueryCost: number; throttleStatus: { maximumAvailable: number; currentlyAvailable: number; restoreRate: number } }`
- `GraphQLResponse<T>`: `{ data: T; errors?: Array<{ message: string; locations?: Array<{ line: number; column: number }> }>; extensions?: { cost: GraphQLCostExtension } }`
- `ShopifyCustomer`: `{ id: string; firstName: string | null; lastName: string | null; email: string | null; phone: string | null; ordersCount: number; totalSpentV2: { amount: string; currencyCode: string }; tags: string[]; createdAt: string; updatedAt: string }`
- `ShopifyOrder`: `{ id: string; name: string; totalPriceSet: { shopMoney: { amount: string; currencyCode: string } }; customer: { id: string } | null; lineItems: { edges: Array<{ node: { title: string; quantity: number; variant: { price: { amount: string } } | null } }> }; financialStatus: string; createdAt: string; updatedAt: string }`
- `ShopifyBulkOperation`: `{ id: string; status: string; errorCode: string | null; objectCount: string; url: string | null; partialDataUrl: string | null }`
- `BulkOperationWebhookPayload`: `{ admin_graphql_api_id: string; status: string; error_code: string | null; object_count: string; url: string | null; type: string }`

**Create `src/lib/shopify/client.ts`:**

Import `env` from `@/lib/env` for SHOPIFY_STORE_URL and SHOPIFY_ACCESS_TOKEN.

Implement `shopifyGraphQL<T>(query: string, variables?: Record<string, unknown>): Promise<GraphQLResponse<T>>`:
1. Build the URL: `${env.SHOPIFY_STORE_URL}/admin/api/2024-10/graphql.json`
2. Make fetch request with headers: `Content-Type: application/json`, `X-Shopify-Access-Token: ${env.SHOPIFY_ACCESS_TOKEN}`
3. Parse response as JSON, cast to `GraphQLResponse<T>`
4. **Cost-based throttling (SHOP-01):** After each response, check `extensions.cost.throttleStatus.currentlyAvailable`. If `currentlyAvailable < requestedQueryCost * 2` (budget getting low), calculate sleep time: `(requestedQueryCost * 2 - currentlyAvailable) / restoreRate * 1000` ms, then `await new Promise(resolve => setTimeout(resolve, sleepMs))`. This proactive backoff prevents 429s.
5. If response contains `errors` and any error message includes "Throttled", sleep for 1 second and retry (max 3 retries with exponential backoff: 1s, 2s, 4s).
6. Throw typed error if all retries exhausted or if non-throttle GraphQL errors present.

Export a convenience wrapper `shopifyClient` object with:
- `query<T>(query: string, variables?: Record<string, unknown>): Promise<T>` — calls shopifyGraphQL and returns just `response.data`, throwing on errors
- `rawQuery<T>(query: string, variables?: Record<string, unknown>): Promise<GraphQLResponse<T>>` — returns full response including extensions for callers that need cost info

Use strict TypeScript (no `any`). Log throttle waits to console.warn for observability.
  </action>
  <verify>TypeScript compilation passes: `node node_modules/typescript/lib/tsc.js --noEmit --project tsconfig.json` (may show env.ts errors from missing env vars — that is expected; verify no errors in shopify/client.ts or shopify/types.ts specifically).</verify>
  <done>Shopify GraphQL client exists at src/lib/shopify/client.ts with cost-based throttling. Types defined in src/lib/shopify/types.ts. No TypeScript errors in shopify files.</done>
</task>

</tasks>

<verification>
- Schema changes generate valid migration SQL via `npx drizzle-kit generate`
- TypeScript compiles without errors in new files
- Client imports env correctly and uses cost-based throttling logic
- All new tables/enums exported at module top level
</verification>

<success_criteria>
- Migration SQL exists with new tables (sync_logs, webhook_deliveries) and new columns (is_historical, deleted_at, shopify_updated_at)
- Shopify GraphQL client handles cost-based throttling per SHOP-01
- All TypeScript types are strict (no `any`)
- Both files importable by downstream plans (02-02, 02-03)
</success_criteria>

<output>
After completion, create `.planning/phases/02-shopify-integration/02-01-SUMMARY.md`
</output>
