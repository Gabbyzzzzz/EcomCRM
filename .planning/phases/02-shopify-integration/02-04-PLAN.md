---
phase: 02-shopify-integration
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/inngest/functions.ts
  - src/lib/db/queries.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "A bulk operation that finishes with status 'failed' or 'cancelled' leaves the syncLog with status='failed', not 'running'"
    - "When all Inngest retries are exhausted for a webhook, the webhookDeliveries row is updated to status='dead_letter' via updateWebhookDeliveryStatus (not recordWebhookDelivery, which would silently skip due to onConflictDoNothing)"
    - "An upsertCustomer call with an older shopifyUpdatedAt than the stored value does NOT overwrite the stored row"
    - "An upsertOrder call with an older shopifyUpdatedAt than the stored value does NOT overwrite the stored row"
  artifacts:
    - path: "src/inngest/functions.ts"
      provides: "Corrected bulk_operations/finish failure path + onFailure dead-letter handler"
      contains: "updateSyncLog.*status.*failed"
    - path: "src/lib/db/queries.ts"
      provides: "True last-write-wins using lte timestamp comparison in setWhere + updateWebhookDeliveryStatus for dead-letter status updates"
      contains: "lte(customers.shopifyUpdatedAt"
      exports: ["updateWebhookDeliveryStatus"]
  key_links:
    - from: "src/inngest/functions.ts (bulk_operations/finish case)"
      to: "src/lib/db/queries.ts (updateSyncLog)"
      via: "db query by bulkOperationId then updateSyncLog call"
      pattern: "updateSyncLog.*status.*failed"
    - from: "src/inngest/functions.ts (onFailure handler)"
      to: "src/lib/db/queries.ts (updateWebhookDeliveryStatus)"
      via: "updateWebhookDeliveryStatus(shopId, webhookId, 'dead_letter')"
      pattern: "dead_letter"
    - from: "src/lib/db/queries.ts (upsertCustomer setWhere)"
      to: "customers.shopifyUpdatedAt column"
      via: "lte comparison against incoming data.shopifyUpdatedAt"
      pattern: "lte\\(customers\\.shopifyUpdatedAt"
---

<objective>
Close the two code-level gaps found during Phase 2 verification.

Gap 1 (Blocker): The `bulk_operations/finish` case in `processShopifyWebhook` logs a warning and breaks when Shopify reports a non-completed status — it never calls `updateSyncLog`, leaving the syncLog permanently in 'running'. Fix: query the syncLog by `bulkOperationId` and call `updateSyncLog` with `status='failed'`. Also add the missing `onFailure` handler to mark dead-letter webhook deliveries.

Gap 2 (Warning): The `onConflictDoUpdate.setWhere` in both `upsertCustomer` and `upsertOrder` only checks `eq(shopId) AND eq(shopifyId)`, which is always true on conflict. The comment says "last-write-wins" but timestamps are never compared. Fix: use `or(isNull(column.shopifyUpdatedAt), lte(column.shopifyUpdatedAt, incoming))` as the setWhere condition.

Purpose: These fixes make sync state correct and last-write-wins semantics real, not just documented.
Output: Two corrected source files. No schema changes, no new files.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-shopify-integration/02-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix bulk_operations/finish failure path and add onFailure dead-letter handler</name>
  <files>src/inngest/functions.ts</files>
  <action>
Two changes to src/inngest/functions.ts:

**Change A — bulk_operations/finish failure path (lines 132-138):**

Replace the current stub that only logs a warning:

```typescript
// BEFORE (lines 132-138):
if (bulkPayload.status !== 'completed') {
  console.warn(
    `[inngest] Bulk operation finished with status ${bulkPayload.status}: ${bulkPayload.error_code ?? 'no error code'}`
  )
  // Find the syncLog and mark it failed
  // bulkOperationId is the admin_graphql_api_id from the payload
  break
}
```

Replace with code that actually queries the syncLog by bulkOperationId and calls updateSyncLog:

```typescript
// AFTER:
if (bulkPayload.status !== 'completed') {
  console.warn(
    `[inngest] Bulk operation finished with status ${bulkPayload.status}: ${bulkPayload.error_code ?? 'no error code'}`
  )
  // Find and mark the syncLog as failed so stale detection and resume logic work correctly
  const { db: failDb } = await import('@/lib/db')
  const { syncLogs: failSyncLogs } = await import('@/lib/db/schema')
  const { eq: failEq, and: failAnd } = await import('drizzle-orm')
  const [failedSyncLog] = await failDb
    .select({ id: failSyncLogs.id })
    .from(failSyncLogs)
    .where(
      failAnd(
        failEq(failSyncLogs.shopId, shopId),
        failEq(failSyncLogs.bulkOperationId, bulkPayload.admin_graphql_api_id)
      )
    )
    .limit(1)
  if (failedSyncLog) {
    await updateSyncLog(failedSyncLog.id, {
      status: 'failed',
      errorMessage: `Bulk operation ended with status: ${bulkPayload.status}${bulkPayload.error_code ? ` (${bulkPayload.error_code})` : ''}`,
      completedAt: new Date(),
    })
  }
  break
}
```

Note: the dynamic imports use aliased names (`failDb`, `failSyncLogs`, `failEq`, `failAnd`) to avoid shadowing the outer scope variables from the same dynamic imports used later in the 'completed' path on lines 148-161. Alternatively, if it's cleaner, extract the db/schema/eq/and imports to the top of the case block before the status check and reuse them in both branches. Prefer whichever approach TypeScript strict mode accepts without duplicate declarations.

**Change B — Add onFailure handler for dead-letter tracking (after line 197):**

Add a third export — the `onFailure` handler for `processShopifyWebhook`. Add it immediately after the `processShopifyWebhook` closing parenthesis (after line 197), before the `scheduledSync` function:

```typescript
// ─── onFailure: dead-letter handler for processShopifyWebhook ─────────────────

/**
 * Called by Inngest after all retries for processShopifyWebhook are exhausted.
 * Updates the webhookDeliveries row to status='dead_letter' so the UI can surface it.
 */
export const processShopifyWebhookFailure = inngest.createFunction(
  {
    id: 'process-shopify-webhook-failure',
    retries: 0,
  },
  { event: 'inngest/function.failed' },
  async ({ event }) => {
    // Guard: only handle failures from the webhook processor, not scheduledSync or other functions
    if (event.data.function_id !== 'process-shopify-webhook') return

    const failedEvent = event.data.event as { data?: { shopId?: string; webhookId?: string; topic?: string } } | undefined
    const shopId = failedEvent?.data?.shopId
    const webhookId = failedEvent?.data?.webhookId
    const topic = failedEvent?.data?.topic ?? 'unknown'

    if (!shopId || !webhookId) {
      console.warn('[inngest] onFailure: missing shopId or webhookId in failed event data')
      return
    }

    console.warn(`[inngest] Dead-lettering webhook ${webhookId} (${topic}) for shop ${shopId}`)
    // Use updateWebhookDeliveryStatus (not recordWebhookDelivery) because the row already exists
    // as 'processing' — recordWebhookDelivery uses onConflictDoNothing and would silently skip.
    await updateWebhookDeliveryStatus(shopId, webhookId, 'dead_letter')
  }
)
```

Then add `processShopifyWebhookFailure` to the exported `functions` array at the bottom of the file:

```typescript
export const functions: InngestFunction.Like[] = [
  processShopifyWebhook,
  processShopifyWebhookFailure,
  scheduledSync,
]
```

Also remove the stale comment on line 193 that said "We update status to 'dead_letter' in the onFailure handler below" since the handler now actually exists above (the comment is now redundant/misleading — just remove it and let the throw speak for itself, or replace with "Inngest retries up to 4 times; processShopifyWebhookFailure handles final dead-letter on exhaustion").

Note: `updateWebhookDeliveryStatus` is added to `src/lib/db/queries.ts` in Task 2. Import it at the top of functions.ts alongside the other query imports. Do NOT call `recordWebhookDelivery` from this handler — it uses `onConflictDoNothing` and will silently skip the update when the 'processing' row already exists.
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit` from /Users/zhangjiabei/Desktop/ecomcrm — must pass with zero errors.

Grep for the fix: `grep -n "status.*failed\|dead_letter\|processShopifyWebhookFailure" /Users/zhangjiabei/Desktop/ecomcrm/src/inngest/functions.ts` — should show updateSyncLog call with 'failed', recordWebhookDelivery call with 'dead_letter', and the new function name.
  </verify>
  <done>
- When bulk_operations/finish arrives with status !== 'completed', the syncLog is queried by bulkOperationId and updateSyncLog is called with status='failed' and a descriptive errorMessage.
- A `processShopifyWebhookFailure` Inngest function exists, listening on `inngest/function.failed`, guarded by `event.data.function_id !== 'process-shopify-webhook'` early return, calling `updateWebhookDeliveryStatus(shopId, webhookId, 'dead_letter')` with shopId and webhookId from the failed event data.
- `processShopifyWebhookFailure` is in the `functions` array.
- `npx tsc --noEmit` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix last-write-wins timestamp comparison in upsertCustomer and upsertOrder</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Two targeted changes to src/lib/db/queries.ts:

**Change A — upsertCustomer setWhere (lines 88-93):**

Update the import on line 3 to add `lte` and `or` (currently imports `eq, and, desc, isNotNull`):

```typescript
import { eq, and, desc, isNotNull, lte, or } from 'drizzle-orm'
```

Replace the current `setWhere` condition:

```typescript
// BEFORE (lines 88-93):
setWhere: data.shopifyUpdatedAt
  ? and(
      eq(customers.shopId, shopId),
      eq(customers.shopifyId, data.shopifyId)
    )
  : undefined,
```

Replace with a real timestamp comparison:

```typescript
// AFTER:
setWhere: data.shopifyUpdatedAt
  ? or(
      isNull(customers.shopifyUpdatedAt),
      lte(customers.shopifyUpdatedAt, data.shopifyUpdatedAt)
    )
  : undefined,
```

Semantics: only apply the update if the stored `shopify_updated_at` is NULL (never set) OR the stored value is <= the incoming value. This means an older webhook replay cannot overwrite a newer stored value.

**Change B — upsertOrder setWhere (lines 162-167):**

Replace the current `setWhere` condition in `upsertOrder`:

```typescript
// BEFORE (lines 162-167):
setWhere: data.shopifyUpdatedAt
  ? and(
      eq(orders.shopId, shopId),
      eq(orders.shopifyId, data.shopifyId)
    )
  : undefined,
```

Replace with:

```typescript
// AFTER:
setWhere: data.shopifyUpdatedAt
  ? or(
      isNull(orders.shopifyUpdatedAt),
      lte(orders.shopifyUpdatedAt, data.shopifyUpdatedAt)
    )
  : undefined,
```

Update the JSDoc comment above `upsertCustomer` (lines 34-42) and `upsertOrder` (lines 113-120) to reflect the corrected semantics:
- "Last-write-wins: only updates if stored shopifyUpdatedAt is NULL or <= incoming value."

**Change C — Add updateWebhookDeliveryStatus function:**

After the existing `recordWebhookDelivery` function, add a new exported function:

```typescript
/**
 * Updates an existing webhookDeliveries row to a new status.
 * Used by the onFailure dead-letter handler where the row already exists as 'processing'.
 * Unlike recordWebhookDelivery (which uses onConflictDoNothing), this does a plain UPDATE.
 */
export async function updateWebhookDeliveryStatus(
  shopId: string,
  webhookId: string,
  status: 'processing' | 'processed' | 'failed' | 'dead_letter'
): Promise<void> {
  await db
    .update(webhookDeliveries)
    .set({ status })
    .where(
      and(
        eq(webhookDeliveries.shopId, shopId),
        eq(webhookDeliveries.webhookId, webhookId)
      )
    )
}
```

Ensure `webhookDeliveries` is imported from `@/lib/db/schema` alongside the other tables already imported in this file.

Do NOT change anything else in the file — the `set` fields, `target`, `values`, return type, or other queries remain as-is.
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit` from /Users/zhangjiabei/Desktop/ecomcrm — must pass with zero errors.

Grep for the fix: `grep -n "lte\|isNull.*shopifyUpdatedAt\|or(" /Users/zhangjiabei/Desktop/ecomcrm/src/lib/db/queries.ts` — should show `lte` and `isNull` calls in both upsert functions, and `or` wrapping them.

Confirm old pattern is gone: `grep -n "eq(customers.shopId, shopId)" /Users/zhangjiabei/Desktop/ecomcrm/src/lib/db/queries.ts` — should return zero results inside setWhere blocks (the eq calls only remain in .where() clauses, not setWhere).

Grep for new function: `grep -n "updateWebhookDeliveryStatus" /Users/zhangjiabei/Desktop/ecomcrm/src/lib/db/queries.ts` — must return the function definition.
  </verify>
  <done>
- `upsertCustomer` setWhere uses `or(isNull(customers.shopifyUpdatedAt), lte(customers.shopifyUpdatedAt, data.shopifyUpdatedAt))`.
- `upsertOrder` setWhere uses `or(isNull(orders.shopifyUpdatedAt), lte(orders.shopifyUpdatedAt, data.shopifyUpdatedAt))`.
- Import line includes `lte, or` alongside existing drizzle-orm imports.
- `updateWebhookDeliveryStatus(shopId, webhookId, status)` is exported from queries.ts and performs a plain UPDATE (not upsert) on the webhookDeliveries table.
- `npx tsc --noEmit` passes.
- An upsert with older shopifyUpdatedAt no longer overwrites a newer stored value.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `npx tsc --noEmit` — zero errors
2. `grep -n "status.*failed" /Users/zhangjiabei/Desktop/ecomcrm/src/inngest/functions.ts` — shows the updateSyncLog call with status='failed' in the bulk_operations/finish failure path
3. `grep -n "dead_letter\|updateWebhookDeliveryStatus" /Users/zhangjiabei/Desktop/ecomcrm/src/inngest/functions.ts` — shows both the onFailure handler body calling updateWebhookDeliveryStatus and the comment on the throw
4. `grep -n "lte\|or(" /Users/zhangjiabei/Desktop/ecomcrm/src/lib/db/queries.ts` — shows lte and or in both upsert setWhere conditions
5. `grep -c "processShopifyWebhookFailure" /Users/zhangjiabei/Desktop/ecomcrm/src/inngest/functions.ts` — returns 3 (export const, function array, and one usage)
</verification>

<success_criteria>
- bulk_operations/finish failure path calls updateSyncLog with status='failed' (Gap 1 code fix — blocker resolved)
- onFailure dead-letter handler exists as exported Inngest function, is guarded by function_id check, calls updateWebhookDeliveryStatus (not recordWebhookDelivery), and is in the functions array (Gap 1 dead-letter fix)
- updateWebhookDeliveryStatus exported from queries.ts does a plain UPDATE (not insert-or-ignore) ensuring the 'processing' row is correctly updated to 'dead_letter'
- upsertCustomer and upsertOrder setWhere use real timestamp comparisons, not always-true equality checks (Gap 2 resolved)
- TypeScript strict mode passes with zero errors after both changes
</success_criteria>

<output>
After completion, create `.planning/phases/02-shopify-integration/02-04-SUMMARY.md`
</output>
