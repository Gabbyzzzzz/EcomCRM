---
phase: 04-email-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/webhooks/resend/route.ts
  - src/app/unsubscribe/page.tsx
  - src/app/api/unsubscribe/route.ts
  - src/lib/db/queries.ts
  - src/inngest/functions.ts
autonomous: true
user_setup:
  - service: resend
    why: "Webhook endpoint for bounce/unsubscribe events"
    env_vars: []
    dashboard_config:
      - task: "Add webhook endpoint URL pointing to /api/webhooks/resend"
        location: "Resend Dashboard -> Webhooks -> Add Webhook -> URL: https://your-app.vercel.app/api/webhooks/resend, Events: email.bounced, email.complained"
      - task: "Verify sending domain (marketing subdomain)"
        location: "Resend Dashboard -> Domains -> Add Domain -> marketing.your-domain.com -> Add DNS records"

must_haves:
  truths:
    - "When Resend fires a hard bounce webhook, the bounced email address is added to the suppressions table and subsequent sends to that address are blocked"
    - "When a customer clicks the unsubscribe link, their marketing_opted_out flag is set to true and an 'unsubscribed' tag is added to their Shopify record"
    - "The unsubscribe confirmation page shows a clear opted-out message with an undo link"
    - "Clicking undo on the unsubscribe page re-subscribes the customer immediately"
    - "Soft bounces do NOT trigger suppression"
    - "The Resend webhook endpoint handles bounce and complaint events and updates the database accordingly"
  artifacts:
    - path: "src/app/api/webhooks/resend/route.ts"
      provides: "POST handler for Resend webhook events (bounce, complaint)"
      exports: ["POST"]
    - path: "src/app/unsubscribe/page.tsx"
      provides: "Unsubscribe confirmation page with undo capability"
    - path: "src/app/api/unsubscribe/route.ts"
      provides: "POST endpoint for one-click unsubscribe, resubscribe, and GET for link-click unsubscribe"
      exports: ["POST", "GET"]
    - path: "src/inngest/functions.ts"
      provides: "Updated functions array including processResendWebhook"
  key_links:
    - from: "src/app/api/webhooks/resend/route.ts"
      to: "src/lib/db/queries.ts"
      via: "insertSuppression on hard bounce, setMarketingOptedOut on complaint"
      pattern: "insertSuppression|setMarketingOptedOut"
    - from: "src/app/api/unsubscribe/route.ts"
      to: "src/lib/shopify/client.ts"
      via: "Shopify Admin API call to add/remove 'unsubscribed' tag to customer"
      pattern: "shopifyGraphQL|shopifyClient"
    - from: "src/app/api/unsubscribe/route.ts"
      to: "src/lib/email/unsubscribe.ts"
      via: "verifyUnsubscribeToken to validate the token before processing"
      pattern: "verifyUnsubscribeToken"
    - from: "src/app/api/unsubscribe/route.ts"
      to: "src/lib/db/queries.ts"
      via: "setMarketingOptedOut + insertSuppression on unsubscribe, removeSuppression on resubscribe"
      pattern: "setMarketingOptedOut|insertSuppression|removeSuppression"
---

<objective>
Wire up the webhook and unsubscribe endpoints that complete the email compliance loop. Resend bounce webhooks suppress addresses, the unsubscribe page confirms opt-out with undo, and Shopify tags sync on unsubscribe.

Purpose: Without these endpoints, bounces go unhandled and unsubscribe links are dead — sending is technically possible from Plan 01 but not compliant. This plan closes the compliance gap.
Output: Resend webhook handler, unsubscribe API + page, Shopify tag sync, updated Inngest functions
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-email-infrastructure/04-01-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/email/unsubscribe.ts
@src/lib/email/send.ts
@src/lib/shopify/client.ts
@src/inngest/functions.ts
@src/app/api/webhooks/shopify/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Resend webhook endpoint + unsubscribe API (including resubscribe) + Shopify tag sync</name>
  <files>
    src/app/api/webhooks/resend/route.ts
    src/app/api/unsubscribe/route.ts
    src/lib/db/queries.ts
    src/inngest/functions.ts
  </files>
  <action>
**Resend webhook endpoint at `src/app/api/webhooks/resend/route.ts`:**

Create a POST handler that receives Resend webhook events. Resend sends JSON payloads with a `type` field.

Per Resend docs, webhook events include:
- `email.bounced` — contains `{ type: 'email.bounced', data: { email_id, from, to, bounce_type, ... } }`
- `email.complained` — spam complaint, treat same as unsubscribe

**Verification:** Skip webhook signature verification for now. Resend uses the `svix` package for webhook verification, which is not in package.json. Add a `// TODO: Add Resend webhook verification using svix package` comment at the top of the handler. For now, parse the body, validate the structure with Zod, and process. This is an accepted known gap.

**Handler logic:**

```typescript
import { z } from 'zod'
import { inngest } from '@/inngest/client'

const resendWebhookSchema = z.object({
  type: z.string(),
  data: z.object({
    email_id: z.string().optional(),
    from: z.string().optional(),
    to: z.union([z.string(), z.array(z.string())]).optional(),
    bounce_type: z.string().optional(),  // 'hard' or 'soft' for bounce events
  }).passthrough(),
})

export async function POST(request: Request) {
  // TODO: Add Resend webhook verification using svix package
  const body = await request.json()
  const parsed = resendWebhookSchema.safeParse(body)
  if (!parsed.success) {
    return new Response('Bad Request', { status: 400 })
  }

  // Dispatch to Inngest for async processing (same pattern as Shopify webhooks)
  await inngest.send({
    name: 'resend/webhook.received',
    data: parsed.data,
  })

  return new Response('OK', { status: 200 })
}
```

**Inngest function `processResendWebhook` in `src/inngest/functions.ts`:**

Add a new Inngest function that handles Resend webhook events:

```typescript
export const processResendWebhook = inngest.createFunction(
  { id: 'process-resend-webhook', retries: 3 },
  { event: 'resend/webhook.received' },
  async ({ event }) => {
    const { type, data } = event.data as { type: string; data: Record<string, unknown> }
    const shopId = getShopId()

    // Extract recipient email(s)
    const toField = data.to
    const emails: string[] = Array.isArray(toField) ? toField : (typeof toField === 'string' ? [toField] : [])

    switch (type) {
      case 'email.bounced': {
        const bounceType = data.bounce_type as string | undefined
        // Only suppress on HARD bounce — soft bounces are transient (per locked decision)
        if (bounceType === 'hard') {
          for (const email of emails) {
            await insertSuppression(shopId, email, 'hard_bounce')
            // Also set marketing_opted_out on the customer if they exist
            const customer = await getCustomerByEmail(shopId, email)
            if (customer) {
              await setMarketingOptedOut(shopId, customer.id, true)
            }
          }
        }
        break
      }
      case 'email.complained': {
        // Spam complaint — treat as unsubscribe
        for (const email of emails) {
          await insertSuppression(shopId, email, 'unsubscribe')
          const customer = await getCustomerByEmail(shopId, email)
          if (customer) {
            await setMarketingOptedOut(shopId, customer.id, true)
          }
        }
        break
      }
      default:
        console.log(`[resend-webhook] Unhandled event type: ${type}`)
    }
  }
)
```

Add `processResendWebhook` to the exported `functions` array.

Import the necessary query functions at the top of `functions.ts`:
```typescript
import {
  insertSuppression,
  setMarketingOptedOut,
  getCustomerByEmail,
  getCustomerByInternalId,
  removeSuppression,
} from '@/lib/db/queries'
```

**Unsubscribe API at `src/app/api/unsubscribe/route.ts`:**

This route handles THREE flows in a single file:

**GET** — Redirect-based unsubscribe (when someone clicks the link in email).
- Read `token` from query params.
- Verify token using `verifyUnsubscribeToken`.
- If valid: perform unsubscribe (set opt-out, insert suppression, sync Shopify tag).
- Redirect to `/unsubscribe?token=${token}&done=true`.
- If invalid token: redirect to `/unsubscribe?error=invalid`.

**POST** — Handles BOTH one-click unsubscribe AND resubscribe, distinguished by request body:

1. **One-click unsubscribe** (EMAIL-05 compliance): Called by email clients that support `List-Unsubscribe-Post`.
   - Body is form-encoded: `List-Unsubscribe=One-Click`.
   - Read `token` from query params (the List-Unsubscribe header URL includes `?token=...`).
   - Verify the token using `verifyUnsubscribeToken`.
   - If valid: call `setMarketingOptedOut(shopId, customerId, true)`, call `insertSuppression(shopId, email, 'unsubscribe')`.
   - Sync to Shopify: Use `shopifyGraphQL` to add the `'unsubscribed'` tag to the customer's Shopify record. The mutation is:
     ```graphql
     mutation addTags($id: ID!, $tags: [String!]!) {
       tagsAdd(id: $id, tags: $tags) {
         userErrors { field message }
       }
     }
     ```
     Where `id` is the customer's Shopify GID (from `customer.shopifyId`), and `tags` is `['unsubscribed']`.
   - Return 200 OK.

2. **Resubscribe** (undo from unsubscribe page): Called by the form on the unsubscribe confirmation page.
   - Body is form-encoded with `action=resubscribe` and `token=xxx`.
   - Verify token using `verifyUnsubscribeToken`.
   - If valid: perform reverse operations:
     - Call `setMarketingOptedOut(shopId, customerId, false)`
     - Call `removeSuppression(shopId, email)`
     - Sync to Shopify: remove the `'unsubscribed'` tag using `tagsRemove` mutation:
       ```graphql
       mutation removeTags($id: ID!, $tags: [String!]!) {
         tagsRemove(id: $id, tags: $tags) {
           userErrors { field message }
         }
       }
       ```
   - Redirect to `/unsubscribe?token=${token}&resubscribed=true`.
   - If invalid token: redirect to `/unsubscribe?error=invalid`.

**Distinguish POST flows:** Check the request Content-Type. If `application/x-www-form-urlencoded`, parse the body. If the body contains `List-Unsubscribe=One-Click`, it's one-click unsubscribe. If the body contains `action=resubscribe`, it's a resubscribe request.

**Add `getCustomerByShopifyId` to `src/lib/db/queries.ts`** if not already present — needed to look up a customer by their Shopify GID for the tag sync mutation. Actually, `verifyUnsubscribeToken` returns `customerId` (internal UUID), so use `getCustomerByInternalId` to get the shopifyId.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with no errors
    2. `src/app/api/webhooks/resend/route.ts` exports POST
    3. `src/app/api/unsubscribe/route.ts` exports GET and POST
    4. `src/inngest/functions.ts` exports `processResendWebhook` in the functions array
    5. The functions array length increases by 1 (from 4 to 5)
    6. POST /api/unsubscribe handles both `List-Unsubscribe=One-Click` and `action=resubscribe` flows
  </verify>
  <done>
    - Resend webhook endpoint receives bounce/complaint events and dispatches to Inngest (with TODO comment for svix verification)
    - Hard bounces insert into suppressions table + set marketing_opted_out (EMAIL-03)
    - Soft bounces are ignored (per locked decision)
    - Spam complaints treated as unsubscribes
    - Unsubscribe API handles POST (one-click unsubscribe), POST (resubscribe/undo), and GET (link click) flows — all in one route.ts
    - Resubscribe reverses: marketing_opted_out=false, suppression removed, Shopify 'unsubscribed' tag removed via tagsRemove mutation
    - Shopify customer gets 'unsubscribed' tag added via Admin API on unsubscribe
    - processResendWebhook Inngest function registered in functions array
  </done>
</task>

<task type="auto">
  <name>Task 2: Unsubscribe confirmation page with undo</name>
  <files>
    src/app/unsubscribe/page.tsx
  </files>
  <action>
**Unsubscribe page at `src/app/unsubscribe/page.tsx`:**

This is a Next.js Server Component page that shows the unsubscribe confirmation.

**URL patterns:**
- `/unsubscribe?token=xxx&done=true` — Successfully unsubscribed
- `/unsubscribe?token=xxx&resubscribed=true` — Successfully re-subscribed (undo worked)
- `/unsubscribe?error=invalid` — Invalid or expired token

**Page behavior:**

Read `searchParams` (token, done, resubscribed, error).

1. **Error state** (`error=invalid`): Show "Invalid or expired unsubscribe link" message. Simple centered card with error text.

2. **Unsubscribed state** (`done=true`): Show "You've been unsubscribed" with:
   - Clear confirmation: "You will no longer receive marketing emails from this store."
   - **Undo form**: A `<form method="POST" action="/api/unsubscribe">` with hidden inputs for `token` and `action=resubscribe`. The submit button says "Re-subscribe" or "Undo".
   - "Changed your mind?" text above the undo button.

3. **Re-subscribed state** (`resubscribed=true`): Show "You've been re-subscribed" with confirmation text: "You will continue to receive marketing emails."

**Design per locked decision:** Simple, clean page. Use Tailwind for styling. Centered card layout, minimal branding (store name from a `storeName` query param if available, or generic text).

The page is a Server Component. The undo action uses a standard HTML `<form>` POST to `/api/unsubscribe` which handles the resubscribe logic (already implemented in Task 1's route.ts). No Client Component needed.

The page should use standard HTML/Tailwind without shadcn/ui dependencies to keep it lightweight (public-facing page, not part of the dashboard). Use the same color scheme as the email templates for visual consistency: primary blue `#2563eb`, text gray-800, background gray-50.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes
    2. `npm run build` succeeds (page compiles as Server Component)
    3. The page renders at `/unsubscribe` route
    4. Page shows different states based on query params (done, resubscribed, error)
    5. Undo form POSTs to `/api/unsubscribe` with action=resubscribe and token hidden inputs
  </verify>
  <done>
    - Unsubscribe page at /unsubscribe shows "You've been unsubscribed" with clear messaging
    - Undo form submits to POST /api/unsubscribe with action=resubscribe (handled by Task 1's route.ts)
    - Re-subscribe confirmation shown after undo
    - Error state shown for invalid tokens
    - Page is lightweight, public-facing, minimal Tailwind styling
    - EMAIL-01 complete: unsubscribe webhook -> marketing_opted_out = true, immediate
    - EMAIL-03 complete: hard bounce -> suppressions table -> future sends blocked
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no type errors
2. `npm run build` — Next.js build succeeds
3. Resend webhook endpoint exists at /api/webhooks/resend
4. Unsubscribe API exists at /api/unsubscribe with GET and POST
5. Unsubscribe page renders at /unsubscribe
6. Inngest functions array has 5 functions (4 existing + processResendWebhook)
7. Hard bounce flow: webhook -> insertSuppression -> future sendMarketingEmail returns suppressed
8. Unsubscribe flow: link click -> API -> marketing_opted_out=true + suppression + Shopify tag
9. Undo flow: undo form POST -> API resubscribe -> marketing_opted_out=false + suppression removed + Shopify tag removed
</verification>

<success_criteria>
- EMAIL-01: Resend webhook fires on unsubscribe -> customer.marketing_opted_out = true immediately
- EMAIL-02: Satisfied by Plan 01's send wrapper gating on marketing_opted_out
- EMAIL-03: Hard bounce -> suppression table -> no further sends to that address
- EMAIL-04: Subdomain documented in .env.local.example (DNS setup is manual per user_setup)
- Unsubscribe page shows confirmation + undo per locked decision
- Shopify tag 'unsubscribed' added on unsubscribe, removed on resubscribe per locked decision
- Soft bounces do NOT suppress per locked decision
</success_criteria>

<output>
After completion, create `.planning/phases/04-email-infrastructure/04-02-SUMMARY.md`
</output>
