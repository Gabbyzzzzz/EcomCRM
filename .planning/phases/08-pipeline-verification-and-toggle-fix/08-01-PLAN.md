---
phase: 08-pipeline-verification-and-toggle-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/automations/test-trigger/route.ts
  - src/inngest/functions.ts
  - src/lib/automation/actions.ts
autonomous: true

must_haves:
  truths:
    - "A POST to /api/automations/test-trigger with a trigger type and customer ID fires the corresponding Inngest event and the automation engine evaluates it"
    - "The welcome flow triggers when a first_order event fires for a customer with orderCount=1"
    - "The winback and repurchase flows trigger from the days_since_order daily cron for eligible customers"
    - "The VIP flow triggers when a segment_change event fires with newSegment=champion"
    - "Each flow produces the correct email template and sends via Resend (verified by message_logs row with status=sent)"
    - "The Shopify webhook payload format is correctly handled — order.id is a GID string, customer fields are extracted without runtime errors"
  artifacts:
    - path: "src/app/api/automations/test-trigger/route.ts"
      provides: "Manual trigger endpoint for testing all 5 automation flows"
      exports: ["POST"]
    - path: "src/inngest/functions.ts"
      provides: "All 9 Inngest functions correctly wired and handling events without runtime errors"
    - path: "src/lib/automation/actions.ts"
      provides: "Email action executor that renders correct template and sends via Resend"
  key_links:
    - from: "src/app/api/webhooks/shopify/route.ts"
      to: "src/inngest/functions.ts (processShopifyWebhook)"
      via: "inngest.send('shopify/webhook.received')"
      pattern: "inngest\\.send.*shopify/webhook\\.received"
    - from: "src/inngest/functions.ts (processShopifyWebhook)"
      to: "src/inngest/functions.ts (processFirstOrder)"
      via: "inngest.send('automation/first_order')"
      pattern: "inngest\\.send.*automation/first_order"
    - from: "src/inngest/functions.ts (processFirstOrder)"
      to: "src/lib/automation/actions.ts (executeEmailAction)"
      via: "function call with shopId, customerId, automationId, emailTemplateId"
      pattern: "executeEmailAction"
    - from: "src/lib/automation/actions.ts"
      to: "src/lib/email/send.ts (sendMarketingEmail)"
      via: "function call with templateFactory"
      pattern: "sendMarketingEmail"
---

<objective>
Trace and debug the full automation pipeline end-to-end, and create a manual test-trigger endpoint so every preset flow can be fired with real customer data to verify email delivery.

Purpose: The pipeline was built in Phases 2-5 but never verified with real Shopify data flowing through. This plan audits the wiring, fixes any payload format mismatches, and adds a test-trigger API so all 5 flows can be exercised manually.

Output: A working /api/automations/test-trigger endpoint that fires any automation trigger, plus any fixes to Inngest functions or action executors needed to make the pipeline work end-to-end.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/inngest/functions.ts
@src/inngest/client.ts
@src/lib/automation/engine.ts
@src/lib/automation/actions.ts
@src/lib/automation/presets.ts
@src/lib/email/send.ts
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/app/api/webhooks/shopify/route.ts
@src/app/api/inngest/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit pipeline wiring and fix payload format issues</name>
  <files>src/inngest/functions.ts, src/lib/automation/actions.ts</files>
  <action>
Trace the full pipeline path for each of the 5 flows and fix any issues found:

1. **Webhook payload format audit**: The Shopify webhook POST body is REST API format (flat JSON with snake_case keys like `id: 123456`, `total_price: "99.00"`, `customer.id: 789`). But `processShopifyWebhook` casts the payload as `ShopifyOrder` (GraphQL format with camelCase keys like `totalPriceSet.shopMoney.amount`, `lineItems.edges[].node`). Check `src/lib/shopify/types.ts` for the ShopifyOrder type definition. If the webhook payload is REST format but the code expects GraphQL format, add a normalization step in the orders/create case that maps REST webhook fields to the expected structure. Common mismatches:
   - REST: `total_price` (string) vs GraphQL: `totalPriceSet.shopMoney.amount`
   - REST: `line_items[].title` vs GraphQL: `lineItems.edges[].node.title`
   - REST: `customer.id` (number) vs GraphQL: `customer.id` (GID string like `gid://shopify/Customer/123`)
   - REST: `id` (number) vs GraphQL: `id` (GID string like `gid://shopify/Order/123`)
   - REST: `financial_status` vs GraphQL: `displayFinancialStatus`
   - REST: `created_at` vs GraphQL: `createdAt`

2. **If webhook payloads ARE already in GraphQL format** (because the webhook route transforms them, or because Shopify sends GraphQL-format payloads for apps configured via GraphQL): Confirm this by reading the webhook route and checking whether any transformation happens. If no transformation, the payload is REST format and needs mapping.

3. **Verify automation event emission**: In the orders/create handler, `automation/first_order` is emitted when `updatedCustomer.orderCount === 1`. Verify this works correctly — the customerRow lookup uses `eq(customersTable.shopifyId, order.customer.id)` which requires the shopifyId format to match. If webhook payload has numeric `customer.id` but DB stores GID format, this comparison will fail silently. Fix by normalizing the ID format.

4. **Verify Inngest event type registration**: All event names used in `inngest.send()` must match the event names in `createFunction({ event: ... })`. Audit:
   - `shopify/webhook.received` -> processShopifyWebhook (check)
   - `automation/first_order` -> processFirstOrder (check)
   - `rfm/segment.changed` -> processSegmentChange (check)
   - `automation/cart_abandoned` -> processCartAbandoned (check)

5. **Verify email template rendering**: In `executeEmailAction`, ensure the template factory produces valid React elements. The WinbackEmail and VipEmail components may require props not being passed (check the email component signatures against what actions.ts provides). Fix any missing required props.

Do NOT change the overall architecture — only fix runtime bugs in the existing code paths. Add console.log breadcrumbs at key points (event emission, automation fetch, email send) for debugging, prefixed with `[pipeline]`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Check that all Inngest event names match between senders and receivers by grepping for event name strings.
  </verify>
  <done>All 5 automation flows have correct wiring from trigger event through to email send, with no type mismatches or payload format issues. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create manual test-trigger API endpoint</name>
  <files>src/app/api/automations/test-trigger/route.ts</files>
  <action>
Create a POST endpoint at `/api/automations/test-trigger` that allows manually firing any automation trigger type for testing.

Request body schema (validated with zod):
```typescript
{
  triggerType: 'first_order' | 'segment_change' | 'days_since_order' | 'cart_abandoned',
  customerId: string,  // internal UUID from customers table
  // Optional overrides:
  newSegment?: string,  // for segment_change trigger (default: 'champion')
}
```

Implementation:
1. Validate request body with zod.
2. Derive shopId from `env.SHOPIFY_STORE_URL` hostname.
3. Look up the customer by internal ID to get their shopifyId (needed for some event payloads). Return 404 if customer not found.
4. Based on triggerType, send the corresponding Inngest event:
   - `first_order`: Send `automation/first_order` event with `{ shopId, customerId, shopifyCustomerId: customer.shopifyId, eventTimestamp: new Date().toISOString() }`
   - `segment_change`: Send `rfm/segment.changed` event with `{ shopId, customerId, oldSegment: null, newSegment: body.newSegment ?? 'champion', eventTimestamp: new Date().toISOString() }`
   - `days_since_order`: This is a cron job, not event-driven. Instead, directly call `fetchEnabledAutomationsByTrigger(shopId, 'days_since_order')` and for each automation, call `executeEmailAction` directly for the given customer (skip the cron scan logic). This gives immediate feedback.
   - `cart_abandoned`: Send `automation/cart_abandoned` event with `{ shopId, customerId, shopifyCustomerId: customer.shopifyId, cartToken: 'test-' + Date.now(), eventTimestamp: new Date().toISOString() }`
5. Return `{ ok: true, triggerType, eventSent: true }` on success.

IMPORTANT: This endpoint is for development/debugging only. Add a guard that checks `process.env.NODE_ENV !== 'production'` and returns 403 in production.

Use TypeScript strict mode, no `any`. Import inngest client, env, db, and automation engine as needed.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Then start the dev server and Inngest dev server, POST to `/api/automations/test-trigger` with `{ "triggerType": "first_order", "customerId": "<real-customer-uuid>" }` and verify the Inngest dashboard shows the event was received and the function was invoked.
  </verify>
  <done>POST /api/automations/test-trigger accepts all 4 trigger types, sends the correct Inngest events (or directly executes for days_since_order), and returns a success response. The endpoint is guarded against production use.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All Inngest event name strings are consistent between senders and receivers
3. POST /api/automations/test-trigger returns 200 for each trigger type when given a valid customer ID
4. Inngest dev server dashboard shows events being received and functions being invoked
5. message_logs table gets new rows after triggering flows (status=sent or status=failed with clear error)
</verification>

<success_criteria>
- The full automation pipeline compiles without type errors and all event wiring is audited and corrected
- A test-trigger endpoint exists for manually firing all 5 automation flows
- After triggering, message_logs rows confirm email send attempts were made
</success_criteria>

<output>
After completion, create `.planning/phases/08-pipeline-verification-and-toggle-fix/08-01-SUMMARY.md`
</output>
