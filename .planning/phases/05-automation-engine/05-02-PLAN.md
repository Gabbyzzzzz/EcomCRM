---
phase: 05-automation-engine
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/inngest/functions.ts
  - src/app/api/automations/seed/route.ts
  - src/app/api/automations/[id]/route.ts
  - src/app/automations/page.tsx
  - src/lib/db/queries.ts
autonomous: false

must_haves:
  truths:
    - "The /automations page loads and shows all 5 preset flows with name, trigger type, status (enabled/disabled), and last run time"
    - "Clicking a toggle on the automations page enables or disables that automation — the change persists in the database"
    - "Customers in at_risk or hibernating segments who have not ordered in 90 days receive the win-back email from the daily cron without manual intervention"
    - "Customers in loyal or new segments who have not ordered in 30 days receive the repurchase email from the daily cron"
    - "The 5 preset automation rows exist in the database after hitting POST /api/automations/seed"
    - "A customer who already received a days_since_order email within the last N days is skipped on subsequent cron runs until they order again"
  artifacts:
    - path: "src/inngest/functions.ts"
      provides: "checkDaysSinceOrder Inngest daily cron function scanning all customers"
      contains: "check-days-since-order"
    - path: "src/app/api/automations/seed/route.ts"
      provides: "POST endpoint to seed 5 preset automations using upsertAutomation"
      exports: ["POST"]
    - path: "src/app/api/automations/[id]/route.ts"
      provides: "PATCH endpoint for enable/disable toggle"
      exports: ["PATCH"]
    - path: "src/app/automations/page.tsx"
      provides: "Server Component listing all automations with toggle client component"
      min_lines: 50
    - path: "src/lib/db/queries.ts"
      provides: "getRecentMessageLog query for duplicate-send guard"
  key_links:
    - from: "src/inngest/functions.ts checkDaysSinceOrder"
      to: "src/lib/automation/engine.ts fetchEnabledAutomationsByTrigger"
      via: "trigger_type='days_since_order'"
      pattern: "fetchEnabledAutomationsByTrigger.*days_since_order"
    - from: "src/inngest/functions.ts checkDaysSinceOrder"
      to: "src/lib/db/queries.ts getRecentMessageLog"
      via: "duplicate-send guard before executeEmailAction"
      pattern: "getRecentMessageLog"
    - from: "src/app/automations/page.tsx"
      to: "src/lib/db/queries.ts listAutomations"
      via: "direct server component DB call"
      pattern: "listAutomations"
    - from: "src/app/automations/[id]/route.ts"
      to: "src/lib/db/queries.ts setAutomationEnabled"
      via: "PATCH handler"
      pattern: "setAutomationEnabled"
---

<objective>
Complete the automation engine by adding: days-since-order daily cron, preset seed endpoint, enable/disable API, and the automation list UI page.

Purpose: The daily cron closes the loop for FLOW-03 (repurchase) and FLOW-04 (win-back) which cannot be event-driven. The UI page satisfies AUTO-07 and lets the user verify all 5 flows are active.
Output: Full Phase 5 feature set operational — all 5 flows configured, cron running, UI showing status with working enable/disable toggle.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-automation-engine/05-01-SUMMARY.md
@src/inngest/functions.ts
@src/lib/automation/engine.ts
@src/lib/automation/presets.ts
@src/lib/db/queries.ts
@src/lib/db/schema.ts
@src/app/(dashboard)/layout.tsx
@src/lib/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Days-since-order cron Inngest function + duplicate-send guard + preset seed API</name>
  <files>
    src/inngest/functions.ts
    src/lib/db/queries.ts
    src/app/api/automations/seed/route.ts
  </files>
  <action>
**Add `getRecentMessageLog` to `src/lib/db/queries.ts`** (append after existing functions):

```ts
/**
 * Returns true if a 'sent' MessageLog record exists for the given
 * (customerId, automationId) pair within the window starting at sinceDate.
 * Used to prevent re-sending days_since_order emails on every cron run.
 */
export async function getRecentMessageLog(
  customerId: string,
  automationId: string,
  sinceDate: Date
): Promise<boolean> {
  const [row] = await db
    .select({ id: messageLogs.id })
    .from(messageLogs)
    .where(
      and(
        eq(messageLogs.customerId, customerId),
        eq(messageLogs.automationId, automationId),
        eq(messageLogs.status, 'sent'),
        gte(messageLogs.sentAt, sinceDate)
      )
    )
    .limit(1)
  return row !== undefined
}
```

Import `gte` from `drizzle-orm` if not already imported in queries.ts.

---

**Add `checkDaysSinceOrder` to `src/inngest/functions.ts`**

Runs daily at 3 AM UTC (after the 2 AM RFM recalculation). Scans all active customers and fires the repurchase and win-back emails for eligible ones.

**IMPORTANT — shopId:** Cron functions have no event payload. Get shopId as the first line of the function body using the existing helper already defined in functions.ts at line 33:

```ts
const shopId = getShopId()
```

Do NOT attempt to read shopId from event.data in this function — cron triggers have no data object.

Logic:
1. `const shopId = getShopId()` — first line in function body
2. `step.run('fetch-automations')` — call `fetchEnabledAutomationsByTrigger(shopId, 'days_since_order')`
3. For each automation, `step.run('scan-customers-{automation.id}')`:
   a. Parse `triggerConfig` as `{ days: number, segments?: string[] }`
   b. Compute `cutoffDate = new Date(Date.now() - config.days * 24 * 60 * 60 * 1000)`
   c. Also compute `dedupeWindowStart = new Date(Date.now() - config.days * 24 * 60 * 60 * 1000)` — same value, used for the MessageLog guard window. The guard logic: skip customers who were already sent this automation within the past `config.days` days (meaning: don't send again until a full cycle has passed).
   d. Query customers: `db.select({ id, lastOrderAt, segment, shopifyId }).from(customers).where(and(eq(customers.shopId, shopId), lte(customers.lastOrderAt, cutoffDate), isNotNull(customers.lastOrderAt), isNull(customers.deletedAt)))` — import `lte, isNull, isNotNull` from drizzle-orm (already imported in file for other uses)
   e. Filter by segment: `evaluateSegmentFilter(automation, customer.segment)` — import from engine
   f. **Duplicate-send guard:** Before calling `executeEmailAction`, call `getRecentMessageLog(customer.id, automation.id, dedupeWindowStart)`. If it returns `true`, skip this customer with a log line: `console.log('[automation] Skipping customer ${customer.id} — already sent automation ${automation.id} within window')`. This prevents the cron from re-sending to the same customer every day they remain past the cutoff.
   g. For each eligible (non-skipped) customer, call `executeEmailAction({ shopId, customerId: customer.id, automationId: automation.id, emailTemplateId: automation.emailTemplateId, eventTimestamp: new Date().toISOString() })`
   h. After all customers processed, call `updateAutomationLastRun(automation.id, new Date())`
4. Log count of emails attempted

**is_historical guard:** days_since_order fires based on `lastOrderAt` field which only updates from real webhook orders (upsertOrder with isHistorical=false updates lastOrderAt via updateCustomerCountersFromOrders). Historical orders DO affect lastOrderAt via the initial sync's counter recalculation — this is acceptable since the cutoff is 30 or 90 days, meaning historical customers won't be spammed immediately unless they genuinely haven't ordered in that long. No additional guard needed.

Import additions at top of functions.ts (append to existing imports — do not duplicate):
```ts
import { evaluateSegmentFilter } from '@/lib/automation/engine'
import { customers as customersTable } from '@/lib/db/schema'
import { getRecentMessageLog } from '@/lib/db/queries'
```

Note: `lte`, `isNull`, `isNotNull`, `and`, `eq`, `gte` are likely already imported — check before adding. The `orders` table may already be imported as `orders` — use `ordersTable` alias if needed to avoid conflict.

Add `checkDaysSinceOrder` to the functions array export at bottom of file.

---

**Create `src/app/api/automations/seed/route.ts`**

POST endpoint to upsert all 5 preset automations for the current shop. No auth guard needed (internal tool — seed runs once at setup).

```ts
import { NextResponse } from 'next/server'
import { PRESET_AUTOMATIONS } from '@/lib/automation/presets'
import { upsertAutomation } from '@/lib/db/queries'
import { env } from '@/lib/env'

export async function POST() {
  const shopId = new URL(env.SHOPIFY_STORE_URL).hostname
  const results = []
  for (const preset of PRESET_AUTOMATIONS) {
    const row = await upsertAutomation(shopId, {
      ...preset,
      triggerConfig: preset.triggerConfig ?? null,
      actionConfig: preset.actionConfig ?? null,
    })
    results.push({ id: row.id, name: row.name })
  }
  return NextResponse.json({ seeded: results.length, automations: results })
}
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` — zero errors
2. `grep -n "check-days-since-order" src/inngest/functions.ts` — function ID present
3. `grep -n "checkDaysSinceOrder" src/inngest/functions.ts` — exported in functions array
4. `grep -n "getShopId" src/inngest/functions.ts` — appears as first call in checkDaysSinceOrder body
5. `grep -n "getRecentMessageLog" src/inngest/functions.ts` — present inside checkDaysSinceOrder scan loop
6. `grep -n "getRecentMessageLog" src/lib/db/queries.ts` — function exported from queries
7. `curl -X POST http://localhost:3000/api/automations/seed` (with dev server running) returns JSON with `seeded: 5`
  </verify>
  <done>checkDaysSinceOrder function exists in functions.ts, starts with `const shopId = getShopId()`, runs on `0 3 * * *` cron, scans customers by lastOrderAt cutoff with segment filter, guards against duplicate sends via getRecentMessageLog before each executeEmailAction call. getRecentMessageLog exported from queries.ts. Seed endpoint returns 5 seeded automations when called.</done>
</task>

<task type="auto">
  <name>Task 2: Automation PATCH API + automation list page</name>
  <files>
    src/app/api/automations/[id]/route.ts
    src/app/automations/page.tsx
  </files>
  <action>
**Create `src/app/api/automations/[id]/route.ts`**

PATCH endpoint for enable/disable toggle. Accepts `{ enabled: boolean }` body, validated with zod.

```ts
import { NextResponse } from 'next/server'
import { z } from 'zod'
import { setAutomationEnabled } from '@/lib/db/queries'

const patchSchema = z.object({
  enabled: z.boolean(),
})

export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  const body = await req.json()
  const parsed = patchSchema.safeParse(body)
  if (!parsed.success) {
    return NextResponse.json({ error: 'Invalid body' }, { status: 400 })
  }
  await setAutomationEnabled(params.id, parsed.data.enabled)
  return NextResponse.json({ ok: true })
}
```

---

**Create `src/app/automations/page.tsx`**

Server Component that fetches automations and renders a list with a client-side toggle component.

Structure:
- Server Component `AutomationsPage` calls `listAutomations(shopId)` directly (using `new URL(env.SHOPIFY_STORE_URL).hostname`)
- Renders a table/list of automation cards showing: name, trigger type (human-readable), delay (if set), action type, status badge (enabled/disabled), lastRunAt (or "Never")
- Each row has an `AutomationToggle` client component that calls `PATCH /api/automations/{id}` and refreshes the page via `router.refresh()`

**`AutomationToggle` client component** (inline in same file or extracted to `src/components/automation-toggle.tsx`):
```tsx
'use client'
import { useTransition } from 'react'
import { useRouter } from 'next/navigation'

export function AutomationToggle({ id, enabled }: { id: string; enabled: boolean }) {
  const router = useRouter()
  const [isPending, startTransition] = useTransition()

  async function toggle() {
    await fetch(`/api/automations/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ enabled: !enabled }),
    })
    startTransition(() => router.refresh())
  }

  return (
    <button
      onClick={toggle}
      disabled={isPending}
      className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none ${
        enabled ? 'bg-primary' : 'bg-muted'
      } disabled:opacity-50`}
      aria-label={enabled ? 'Disable automation' : 'Enable automation'}
    >
      <span
        className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
          enabled ? 'translate-x-6' : 'translate-x-1'
        }`}
      />
    </button>
  )
}
```

**Page layout** — use the existing dashboard card/border pattern (see `src/app/(dashboard)/page.tsx` for reference style):
- Page title: "Automations"
- Subtitle: "Preset email flows that fire automatically on customer events"
- If no automations: show empty state with a "Seed preset flows" button pointing to the seed endpoint
- Table columns: Flow Name | Trigger | Delay | Action | Status | Last Run | Toggle
- Human-readable trigger labels:
  - first_order -> "First order placed"
  - segment_change -> "Segment changes to champion"
  - days_since_order (30 days) -> "30 days since last order"
  - days_since_order (90 days) -> "90 days since last order"
  - cart_abandoned -> "Cart abandoned"
- Last Run: format using `lastRunAt ? new Date(lastRunAt).toLocaleString() : 'Never'`

Import `listAutomations` from `@/lib/db/queries` and `env` from `@/lib/env`.
  </action>
  <verify>
1. `npx tsc --noEmit` — zero errors
2. `curl -X PATCH http://localhost:3000/api/automations/test-id -d '{"enabled":false}' -H 'Content-Type: application/json'` returns 400 (invalid UUID is fine) or 200
3. Visit http://localhost:3000/automations — page renders without error (even with empty automations)
  </verify>
  <done>PATCH /api/automations/[id] accepts { enabled: boolean } and updates the row. /automations page renders the automation list with name, trigger, delay, status badge, last run time, and working toggle per row.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete Phase 5 automation engine</name>
  <action>
Human verification step. All automated tasks above are complete. Verify the Phase 5 automation engine works end-to-end:
1. Seed preset flows via POST /api/automations/seed
2. Visit /automations and confirm all 5 flows are listed with name, trigger, status, and toggle
3. Test the enable/disable toggle
4. Confirm all 4 new Inngest functions are registered in the Inngest Dev Server
  </action>
  <verify>
    1. Start the dev server: `npm run dev`
    2. Seed the preset automations: `curl -X POST http://localhost:3000/api/automations/seed`
       Expected: `{"seeded":5,"automations":[...5 named flows...]}`
    3. Visit http://localhost:3000/automations
       Expected: All 5 flows listed — Welcome Flow, Abandoned Cart Recovery, Repurchase Prompt, Win-Back Campaign, VIP Welcome
    4. Toggle one automation (e.g. disable "VIP Welcome")
       Expected: Toggle flips to disabled state, page refreshes, row shows disabled
    5. Re-enable it. Confirm it returns to enabled.
    6. Open the Inngest Dev Server (http://localhost:8288 or your Inngest dashboard)
       Expected: 9 registered functions (5 existing + processFirstOrder, processSegmentChange, processCartAbandoned, checkDaysSinceOrder) visible
    7. Check TypeScript: `npx tsc --noEmit` — zero errors
  </verify>
  <done>All 5 preset flows visible in /automations, toggle persists enable/disable state, all 9 Inngest functions registered, TypeScript passes with zero errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. POST /api/automations/seed returns `{ seeded: 5 }` and inserts rows in automations table
3. GET /automations renders all 5 preset flows
4. PATCH /api/automations/{id} with `{ enabled: false }` updates the row and the page reflects the change on refresh
5. Inngest Dev Server shows checkDaysSinceOrder registered with `0 3 * * *` cron schedule
6. processFirstOrder, processSegmentChange, processCartAbandoned all registered in Inngest
7. `grep -n "getShopId" src/inngest/functions.ts` — appears as first call in checkDaysSinceOrder body (not reading from event.data)
8. `grep -n "getRecentMessageLog" src/inngest/functions.ts` — present inside the customer scan loop in checkDaysSinceOrder
</verification>

<success_criteria>
- checkDaysSinceOrder cron function created and exported in functions array
- checkDaysSinceOrder starts with `const shopId = getShopId()` (not event.data)
- checkDaysSinceOrder has MessageLog duplicate-send guard via getRecentMessageLog before each executeEmailAction
- getRecentMessageLog appended to queries.ts
- POST /api/automations/seed endpoint seeds 5 preset automations via upsertAutomation
- PATCH /api/automations/[id] accepts { enabled: boolean } and updates row
- /automations page lists all automations with name, trigger, delay, status, lastRunAt, and toggle
- Human verified: 5 flows seeded, toggle works, Inngest shows all 9 functions
</success_criteria>

<output>
After completion, create `.planning/phases/05-automation-engine/05-02-SUMMARY.md`
</output>
