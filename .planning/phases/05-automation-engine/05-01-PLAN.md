---
phase: 05-automation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/automation/engine.ts
  - src/lib/automation/actions.ts
  - src/lib/automation/presets.ts
  - src/lib/db/queries.ts
  - src/inngest/functions.ts
autonomous: true

must_haves:
  truths:
    - "A first_order webhook event triggers the welcome Inngest function which sleeps 1 hour then sends welcome email — no duplicate send on Inngest retry"
    - "A rfm/segment.changed event to 'champion' triggers the VIP Inngest function which sends VIP email and adds 'vip' tag to Shopify"
    - "A cart_abandoned event triggers the abandoned-cart Inngest function which waits 2 hours then checks if an order was placed; if so, cancels the send"
    - "All automation functions skip customers where is_historical = true on the triggering order"
    - "Action executors write to MessageLog with automationId on every send attempt (sent or suppressed)"
  artifacts:
    - path: "src/lib/automation/engine.ts"
      provides: "fetchEnabledAutomationsByTrigger, evaluateSegmentFilter"
      exports: ["fetchEnabledAutomationsByTrigger", "evaluateSegmentFilter"]
    - path: "src/lib/automation/actions.ts"
      provides: "executeEmailAction, executeTagAction"
      exports: ["executeEmailAction", "executeTagAction"]
    - path: "src/lib/automation/presets.ts"
      provides: "PRESET_AUTOMATIONS constant — 5 flow configs for DB seed"
      exports: ["PRESET_AUTOMATIONS"]
    - path: "src/lib/db/queries.ts"
      provides: "getEnabledAutomationsByTrigger, upsertAutomation, listAutomations, setAutomationEnabled, updateAutomationLastRun"
    - path: "src/inngest/functions.ts"
      provides: "processFirstOrder, processSegmentChange, processCartAbandoned Inngest functions; all exported in functions array"
  key_links:
    - from: "src/inngest/functions.ts processShopifyWebhook"
      to: "inngest.send('automation/first_order')"
      via: "orders/create case when isHistorical=false and orderCount===1"
      pattern: "automation/first_order"
    - from: "src/inngest/functions.ts processFirstOrder"
      to: "src/lib/automation/engine.ts fetchEnabledAutomationsByTrigger"
      via: "trigger_type='first_order'"
      pattern: "fetchEnabledAutomationsByTrigger"
    - from: "src/lib/automation/actions.ts executeEmailAction"
      to: "src/lib/email/send.ts sendMarketingEmail"
      via: "templateFactory pattern"
      pattern: "sendMarketingEmail"
    - from: "src/lib/automation/actions.ts executeTagAction"
      to: "src/lib/shopify/client.ts shopifyGraphQL"
      via: "tagsAdd/tagsRemove mutation"
      pattern: "shopifyGraphQL.*tagsAdd|tagsRemove"
---

<objective>
Build the automation engine core: trigger evaluation helpers, action executors, preset configurations, and Inngest functions for the three event-driven trigger types (first_order, segment_change, cart_abandoned).

Purpose: This is the foundational layer — everything Phase 5 success criteria depends on. Without this plan, no automation can fire.
Output: A working automation engine where first_order, segment_change, and cart_abandoned triggers evaluate, delay via step.sleep(), and execute email + tag actions with idempotency and MessageLog writes.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-email-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-email-infrastructure/04-02-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/email/send.ts
@src/lib/email/unsubscribe.ts
@src/lib/shopify/client.ts
@src/inngest/functions.ts
@src/inngest/client.ts
@src/emails/welcome.tsx
@src/emails/abandoned-cart.tsx
@src/emails/repurchase.tsx
@src/emails/winback.tsx
@src/emails/vip.tsx
@src/lib/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Automation engine helpers + action executors</name>
  <files>
    src/lib/automation/engine.ts
    src/lib/automation/actions.ts
    src/lib/automation/presets.ts
    src/lib/db/queries.ts
  </files>
  <action>
**Create `src/lib/automation/engine.ts`**

Exports:
- `fetchEnabledAutomationsByTrigger(shopId: string, triggerType: string): Promise<AutomationRow[]>` — queries `automations` table via Drizzle where `enabled=true AND trigger_type=triggerType AND shop_id=shopId`. Returns full rows.
- `evaluateSegmentFilter(automation: AutomationRow, customerSegment: string | null): boolean` — reads `automation.triggerConfig` as `{ segments?: string[] }`, returns true if no segments filter OR customerSegment is in the list.
- Export type `AutomationRow` matching the Drizzle select result from `automations` table.

**Add to `src/lib/db/queries.ts`** (append after existing functions):
- `getEnabledAutomationsByTrigger(shopId: string, triggerType: 'first_order' | 'segment_change' | 'days_since_order' | 'tag_added' | 'cart_abandoned'): Promise<AutomationRow[]>` — same query as above, exported for use in Inngest functions
- `upsertAutomation(shopId: string, data: AutomationInsert): Promise<AutomationRow>` — inserts with `onConflictDoUpdate` on `(shopId, name)` — name is the stable preset identifier. Returns row.
- `listAutomations(shopId: string): Promise<AutomationRow[]>` — select all for shop ordered by createdAt asc
- `setAutomationEnabled(id: string, enabled: boolean): Promise<void>` — update single row
- `updateAutomationLastRun(id: string, lastRunAt: Date): Promise<void>` — update lastRunAt on a row

For `upsertAutomation`, add a `uniqueIndex` target of `(shopId, name)` to `automations` table in schema.ts. Add `uniqueIndex('automations_shop_name_unique').on(table.shopId, table.name)` to the automations table definition in `src/lib/db/schema.ts`.

**Create `src/lib/automation/actions.ts`**

Exports:
- `executeEmailAction(params: EmailActionParams): Promise<void>` — calls `sendMarketingEmail` with correct templateFactory based on `emailTemplateId`. Idempotency key format: `${automationId}-${customerId}-${eventTimestamp}`. Supported templateIds: `'welcome'`, `'abandoned-cart'`, `'repurchase'`, `'winback'`, `'vip'`. Build templateFactory using the correct React Email component and reasonable default props (storeName from `env.RESEND_FROM_NAME`, customerName from customer lookup optional, use Decimal to format totalSpent for VIP template). For abandoned-cart, pass `cartItems: []` and `cartUrl: env.SHOPIFY_STORE_URL` (cart items from live Shopify not available at delay time — use store URL as fallback). For repurchase, pass `lastOrderDate: lastOrderAt.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })` from customer row or empty string. For winback, compute `daysSinceLastOrder` from customer.lastOrderAt. For VIP, format `totalSpent` via Decimal as `$X,XXX.XX`.
- `executeTagAction(shopId: string, shopifyCustomerId: string, tag: string, action: 'add' | 'remove'): Promise<void>` — calls `shopifyGraphQL` with `tagsAdd` mutation for 'add', `tagsRemove` for 'remove'. Best-effort: catch and log errors, do not throw (matching Phase 4 pattern from unsubscribe route).

EmailActionParams interface:
```ts
interface EmailActionParams {
  shopId: string
  customerId: string       // internal UUID
  automationId: string
  emailTemplateId: string
  eventTimestamp: string   // ISO string, used in idempotency key
}
```

**Create `src/lib/automation/presets.ts`**

Export `PRESET_AUTOMATIONS` as a readonly array of 5 automation configs (minus id/shopId/createdAt — those are added at seed time):

```ts
export const PRESET_AUTOMATIONS = [
  {
    name: 'Welcome Flow',
    triggerType: 'first_order' as const,
    triggerConfig: {},
    delayValue: 1,
    delayUnit: 'hours',
    actionType: 'send_email' as const,
    actionConfig: {},
    emailTemplateId: 'welcome',
    enabled: true,
  },
  {
    name: 'Abandoned Cart Recovery',
    triggerType: 'cart_abandoned' as const,
    triggerConfig: {},
    delayValue: 2,
    delayUnit: 'hours',
    actionType: 'send_email' as const,
    actionConfig: {},
    emailTemplateId: 'abandoned-cart',
    enabled: true,
  },
  {
    name: 'Repurchase Prompt',
    triggerType: 'days_since_order' as const,
    triggerConfig: { days: 30, segments: ['loyal', 'new'] },
    delayValue: null,
    delayUnit: null,
    actionType: 'send_email' as const,
    actionConfig: {},
    emailTemplateId: 'repurchase',
    enabled: true,
  },
  {
    name: 'Win-Back Campaign',
    triggerType: 'days_since_order' as const,
    triggerConfig: { days: 90, segments: ['at_risk', 'hibernating'] },
    delayValue: null,
    delayUnit: null,
    actionType: 'send_email' as const,
    actionConfig: {},
    emailTemplateId: 'winback',
    enabled: true,
  },
  {
    name: 'VIP Welcome',
    triggerType: 'segment_change' as const,
    triggerConfig: { toSegment: 'champion' },
    delayValue: null,
    delayUnit: null,
    actionType: 'send_email' as const,
    actionConfig: { alsoAddTag: 'vip' },
    emailTemplateId: 'vip',
    enabled: true,
  },
] as const
```

Note: VIP flow uses `alsoAddTag` in actionConfig to signal that `executeTagAction` should also run after the email. This is read by the Inngest functions in Task 2.
  </action>
  <verify>Run `npx tsc --noEmit` from the project root — zero type errors in the new files.</verify>
  <done>All four files exist with no TypeScript errors. `engine.ts` exports `fetchEnabledAutomationsByTrigger` and `evaluateSegmentFilter`. `actions.ts` exports `executeEmailAction` and `executeTagAction`. `presets.ts` exports `PRESET_AUTOMATIONS` with 5 entries. `queries.ts` has the 5 new query functions appended. `schema.ts` has the unique index added to automations table.</done>
</task>

<task type="auto">
  <name>Task 2: Event-driven Inngest automation functions (first_order, segment_change, cart_abandoned)</name>
  <files>
    src/inngest/functions.ts
  </files>
  <action>
**Extend `src/inngest/functions.ts`** to add three new Inngest functions. Append to the file (do not remove existing functions). Update the `functions` array export to include the three new functions.

Also update the `orders/create` case inside `processShopifyWebhook` to emit an `automation/first_order` event when:
- `topic === 'orders/create'`
- `isHistorical = false` (already the case for webhook orders — per existing comment)
- The customer's `orderCount === 1` after `updateCustomerCountersFromOrders` runs (re-fetch customer row after update to get updated orderCount)

Emit via `inngest.send({ name: 'automation/first_order', data: { shopId, customerId: customerRow.id, shopifyCustomerId: order.customer?.id, orderId: orderRow?.id, eventTimestamp: new Date().toISOString() } })` — wrap in try/catch, log but do not throw (event emission failure must not break webhook processing).

---

**Function 6: `processFirstOrder`**

```ts
inngest.createFunction(
  { id: 'process-first-order', retries: 3 },
  { event: 'automation/first_order' },
  async ({ event, step }) => {
    const { shopId, customerId, eventTimestamp } = event.data
    const automations = await step.run('fetch-automations', async () =>
      fetchEnabledAutomationsByTrigger(shopId, 'first_order')
    )
    for (const automation of automations) {
      // Delay — step.sleep uses automation.delayValue + delayUnit
      if (automation.delayValue && automation.delayUnit) {
        const sleepFor = `${automation.delayValue}${automation.delayUnit === 'hours' ? 'h' : 'd'}`
        await step.sleep(`delay-${automation.id}`, sleepFor)
      }
      await step.run(`execute-${automation.id}`, async () => {
        await executeEmailAction({
          shopId,
          customerId,
          automationId: automation.id,
          emailTemplateId: automation.emailTemplateId ?? 'welcome',
          eventTimestamp,
        })
        await updateAutomationLastRun(automation.id, new Date())
      })
    }
  }
)
```

**Function 7: `processSegmentChange`**

Listen to `rfm/segment.changed`. For each enabled `segment_change` automation:
- Check `triggerConfig.toSegment === newSegment` (exact match — only fire when transitioning TO the configured segment)
- No delay (delayValue is null for VIP flow)
- Call `executeEmailAction`
- If `automation.actionConfig.alsoAddTag` exists, call `executeTagAction(shopId, shopifyCustomerId, alsoAddTag, 'add')` — need shopifyCustomerId from DB lookup of customerId

Re-fetch customer from DB in the step to get `shopifyId` for the tag action. Use `getCustomerByInternalId(shopId, customerId)` (already in queries).

```ts
inngest.createFunction(
  { id: 'process-segment-change', retries: 3 },
  { event: 'rfm/segment.changed' },
  async ({ event, step }) => {
    const { shopId, customerId, newSegment } = event.data
    const eventTimestamp = new Date().toISOString()
    const automations = await step.run('fetch-automations', async () =>
      fetchEnabledAutomationsByTrigger(shopId, 'segment_change')
    )
    for (const automation of automations) {
      const config = automation.triggerConfig as { toSegment?: string } | null
      if (config?.toSegment !== newSegment) continue
      await step.run(`execute-${automation.id}`, async () => {
        await executeEmailAction({ shopId, customerId, automationId: automation.id, emailTemplateId: automation.emailTemplateId ?? 'vip', eventTimestamp })
        const actionConfig = automation.actionConfig as { alsoAddTag?: string } | null
        if (actionConfig?.alsoAddTag) {
          const customer = await getCustomerByInternalId(shopId, customerId)
          if (customer?.shopifyId) {
            await executeTagAction(shopId, customer.shopifyId, actionConfig.alsoAddTag, 'add')
          }
        }
        await updateAutomationLastRun(automation.id, new Date())
      })
    }
  }
)
```

**Function 8: `processCartAbandoned`**

Listen to `automation/cart_abandoned`. This event is emitted from the Shopify `checkouts/create` webhook (Phase 6 concern) but must be handled now. The function:
1. Receives `{ shopId, customerId, shopifyCustomerId, cartToken, eventTimestamp }`
2. Fetches enabled `cart_abandoned` automations
3. For each, calls `step.sleep('delay', '2h')` (or reads delayValue from automation)
4. After sleep, checks if customer placed an order AFTER `eventTimestamp` using a DB query: `db.select().from(orders).where(and(eq(orders.customerId, customerId), gte(orders.shopifyCreatedAt, new Date(eventTimestamp)), eq(orders.isHistorical, false))).limit(1)` — import `gte` from drizzle-orm
5. If order found → log "order placed, cancelling cart email" and skip
6. If no order → call `executeEmailAction`

```ts
inngest.createFunction(
  { id: 'process-cart-abandoned', retries: 3 },
  { event: 'automation/cart_abandoned' },
  async ({ event, step }) => {
    const { shopId, customerId, eventTimestamp } = event.data
    const automations = await step.run('fetch-automations', async () =>
      fetchEnabledAutomationsByTrigger(shopId, 'cart_abandoned')
    )
    for (const automation of automations) {
      if (automation.delayValue && automation.delayUnit) {
        const sleepFor = `${automation.delayValue}${automation.delayUnit === 'hours' ? 'h' : 'd'}`
        await step.sleep(`delay-${automation.id}`, sleepFor)
      }
      await step.run(`check-and-send-${automation.id}`, async () => {
        // Cancel if order was placed during the delay window
        const [orderSinceAbandonment] = await db
          .select({ id: orders.id })
          .from(orders)
          .where(
            and(
              eq(orders.customerId, customerId),
              gte(orders.shopifyCreatedAt, new Date(eventTimestamp)),
              eq(orders.isHistorical, false)
            )
          )
          .limit(1)
        if (orderSinceAbandonment) {
          console.log(`[automation] Cart recovery cancelled — order placed for customer ${customerId}`)
          return
        }
        await executeEmailAction({ shopId, customerId, automationId: automation.id, emailTemplateId: automation.emailTemplateId ?? 'abandoned-cart', eventTimestamp })
        await updateAutomationLastRun(automation.id, new Date())
      })
    }
  }
)
```

**Imports to add at top of functions.ts:**
```ts
import { fetchEnabledAutomationsByTrigger, evaluateSegmentFilter } from '@/lib/automation/engine'
import { executeEmailAction, executeTagAction } from '@/lib/automation/actions'
import { updateAutomationLastRun } from '@/lib/db/queries'
import { orders as ordersTable } from '@/lib/db/schema'
import { gte } from 'drizzle-orm'
```

Note: reference `orders` as `ordersTable` (or use existing import pattern in file — check that `orders` isn't already imported with a different alias).

Also update the `functions` array at the bottom to export the 3 new functions.

**IMPORTANT — is_historical guard in orders/create:**
In the `orders/create` webhook handler, before emitting `automation/first_order`, verify the order is not historical. Webhook orders are always `isHistorical=false` (per comment in existing code), so no additional guard is needed beyond only emitting for `orders/create` topic (not `orders/updated`). The orderCount check guards against repeat triggers: only emit when `customerRow.orderCount === 1` after counter update.
  </action>
  <verify>Run `npx tsc --noEmit` — zero errors. Run `grep -n "process-first-order\|process-segment-change\|process-cart-abandoned" src/inngest/functions.ts` — all three IDs present.</verify>
  <done>Three new Inngest functions exist in functions.ts and are in the exported functions array. processShopifyWebhook emits automation/first_order for first-time orders. TypeScript strict mode passes with no errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all modified files
2. `grep -rn "processFirstOrder\|processSegmentChange\|processCartAbandoned" src/inngest/functions.ts` shows all three functions
3. `grep -n "automation/first_order" src/inngest/functions.ts` shows the event emitted in orders/create case AND consumed by processFirstOrder
4. `grep -n "rfm/segment.changed" src/inngest/functions.ts` shows the event consumed by processSegmentChange
5. `grep -n "PRESET_AUTOMATIONS" src/lib/automation/presets.ts` shows 5 entries
6. `grep -n "executeEmailAction\|executeTagAction" src/lib/automation/actions.ts` shows both exports
</verification>

<success_criteria>
- engine.ts, actions.ts, presets.ts created in src/lib/automation/
- 5 new DB query functions appended to queries.ts
- unique index added to automations table in schema.ts
- 3 new Inngest functions (processFirstOrder, processSegmentChange, processCartAbandoned) in functions.ts
- functions array updated with all 3 new functions
- processShopifyWebhook emits automation/first_order on first order (orderCount===1, isHistorical=false)
- TypeScript strict mode: zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-automation-engine/05-01-SUMMARY.md`
</output>
