---
phase: 13-email-template-editor
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/components/email-editor/UnlayerEditor.tsx
  - src/app/(dashboard)/emails/[id]/edit/page.tsx
  - src/app/api/uploads/image/route.ts
  - src/app/(dashboard)/emails/[id]/page.tsx
autonomous: true
user_setup:
  - service: supabase-storage
    why: "Image uploads from Unlayer editor need a public storage bucket"
    dashboard_config:
      - task: "Create 'email-assets' bucket as PUBLIC"
        location: "Supabase Dashboard -> Storage -> New bucket -> name: 'email-assets', toggle 'Public bucket' ON"

must_haves:
  truths:
    - "/emails/[id]/edit opens the Unlayer drag-and-drop editor with full editing capabilities (text, images, buttons, colors, fonts)"
    - "Saving a template persists both HTML and Design JSON to the database"
    - "Reopening a saved template loads the Design JSON back into Unlayer for continued editing"
    - "Images uploaded in the Unlayer editor are stored in Supabase Storage and inserted as public URLs"
  artifacts:
    - path: "src/components/email-editor/UnlayerEditor.tsx"
      provides: "Client Component wrapping react-email-editor with dynamic import, save handler, image upload callback"
      min_lines: 60
    - path: "src/app/(dashboard)/emails/[id]/edit/page.tsx"
      provides: "Server Component that loads template from DB and renders UnlayerEditor"
      min_lines: 30
    - path: "src/app/api/uploads/image/route.ts"
      provides: "POST endpoint accepting multipart FormData, uploading to Supabase Storage, returning public URL"
      exports: ["POST"]
    - path: "src/app/(dashboard)/emails/[id]/page.tsx"
      provides: "Redirect from /emails/[id] to /emails/[id]/edit"
      min_lines: 5
  key_links:
    - from: "src/components/email-editor/UnlayerEditor.tsx"
      to: "/api/email-templates/[id]"
      via: "fetch PUT on save"
      pattern: "fetch.*api/email-templates"
    - from: "src/components/email-editor/UnlayerEditor.tsx"
      to: "/api/uploads/image"
      via: "registerCallback('image') -> fetch POST"
      pattern: "fetch.*api/uploads/image"
    - from: "src/app/api/uploads/image/route.ts"
      to: "supabase.storage"
      via: "Supabase client upload + getPublicUrl"
      pattern: "supabase\\.storage\\.from.*upload"
    - from: "src/app/(dashboard)/emails/[id]/edit/page.tsx"
      to: "src/lib/db/queries.ts"
      via: "getEmailTemplate server call"
      pattern: "getEmailTemplate"
---

<objective>
Integrate the Unlayer drag-and-drop email editor at `/emails/[id]/edit` with save/load of HTML + Design JSON, and image upload to Supabase Storage.

Purpose: This is the core editing experience — merchants can visually design email templates with drag-and-drop, save their work, and re-open for continued editing. Images uploaded in the editor are stored in Supabase Storage.
Output: Working editor page at `/emails/[id]/edit` with save, load, and image upload functionality.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-email-template-editor/13-RESEARCH.md
@.planning/phases/13-email-template-editor/13-01-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-email-editor, create UnlayerEditor client component and image upload API</name>
  <files>src/components/email-editor/UnlayerEditor.tsx, src/app/api/uploads/image/route.ts</files>
  <action>
1. **Install the package**: `npm install react-email-editor`

2. **Create `src/components/email-editor/UnlayerEditor.tsx`** — a `'use client'` component:

```typescript
'use client'

import dynamic from 'next/dynamic'
import { useRef, useCallback, useState } from 'react'
import type { EditorRef, EmailEditorProps } from 'react-email-editor'
import { useRouter } from 'next/navigation'

// MUST be at module level, not inside component
const EmailEditor = dynamic(() => import('react-email-editor'), { ssr: false })
```

Props interface:
```typescript
interface UnlayerEditorProps {
  templateId: string
  templateName: string
  initialDesign: object | null
}
```

Component implementation:
- Use `useRef<EditorRef>(null)` for the editor ref.
- Use a `useRef<boolean>(false)` as `designLoadedRef` to prevent React StrictMode double-fire of `loadDesign`.
- Use `useState<boolean>(false)` for `saving` state to disable save button during save.
- Use `useState<boolean>(false)` for `editorReady` state to disable save button until editor is initialized.

**`onReady` callback** (use `useCallback` with `[initialDesign]` dependency):
- Set `editorReady` to `true`.
- If `initialDesign` is not null AND `designLoadedRef.current` is false: call `unlayer.loadDesign(initialDesign as Parameters<typeof unlayer.loadDesign>[0])`, set `designLoadedRef.current = true`.
- Register the image upload callback:
  ```typescript
  unlayer.registerCallback('image', async (file: { attachments: File[] }, done: (result: { progress: number; url?: string }) => void) => {
    done({ progress: 0 })
    const formData = new FormData()
    formData.append('file', file.attachments[0])
    const res = await fetch('/api/uploads/image', { method: 'POST', body: formData })
    if (!res.ok) { done({ progress: 0 }); return }
    const { url } = await res.json()
    done({ progress: 100, url })
  })
  ```

**`handleSave` callback**: Wrap `exportHtml` in a Promise for cleaner async flow:
```typescript
const handleSave = useCallback(async () => {
  if (!editorRef.current?.editor) return
  setSaving(true)
  try {
    const data = await new Promise<{ html: string; design: object }>((resolve) => {
      editorRef.current!.editor!.exportHtml((d) => resolve({ html: d.html, design: d.design }))
    })
    await fetch(`/api/email-templates/${templateId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ html: data.html, designJson: data.design }),
    })
  } finally {
    setSaving(false)
  }
}, [templateId])
```

**Render**:
```tsx
<div className="flex flex-col h-screen">
  <div className="flex items-center justify-between px-4 py-2 border-b bg-card shrink-0">
    <div className="flex items-center gap-3">
      <button onClick={() => router.push('/emails')} className="text-sm text-muted-foreground hover:text-foreground">
        &larr; Back
      </button>
      <h1 className="text-sm font-medium">{templateName}</h1>
    </div>
    <button
      onClick={handleSave}
      disabled={saving || !editorReady}
      className="px-4 py-1.5 bg-primary text-primary-foreground text-sm rounded-md hover:bg-primary/90 disabled:opacity-50"
    >
      {saving ? 'Saving...' : 'Save Template'}
    </button>
  </div>
  <EmailEditor
    ref={editorRef}
    onReady={onReady}
    minHeight="calc(100vh - 49px)"
    options={{
      version: '1.157.0',
      appearance: { theme: 'modern_light' },
    }}
  />
</div>
```

**CRITICAL**: Pin Unlayer engine version to `'1.157.0'` in the options object. This is required for `registerCallback('image')` to work on the free tier. Do NOT use `'latest'`.

3. **Create `src/app/api/uploads/image/route.ts`** — POST handler for image uploads:

- Import `createClient` from `@supabase/supabase-js`.
- Create a Supabase client using `env.NEXT_PUBLIC_SUPABASE_URL` and `env.SUPABASE_SERVICE_ROLE_KEY` (service role — server-side only, never exposed to browser).
- Parse FormData: `const file = formData.get('file') as File | null`. Return 400 if no file.
- Validate file type: only allow `image/jpeg`, `image/png`, `image/gif`, `image/webp`, `image/svg+xml`. Return 400 if invalid.
- Validate file size: max 5MB. Return 400 if too large.
- Generate path: `email-images/${Date.now()}-${Math.random().toString(36).slice(2)}.${ext}` where ext is from the original filename.
- Upload: `supabase.storage.from('email-assets').upload(path, file, { contentType: file.type, upsert: false })`. Return 500 on error.
- Get public URL: `supabase.storage.from('email-assets').getPublicUrl(path)`. Return `{ url: data.publicUrl }`.

**NOTE**: The `email-assets` bucket must be created as PUBLIC in the Supabase dashboard before this works. This is documented in the user_setup frontmatter and verified in the verification section.
  </action>
  <verify>
- `npm ls react-email-editor` shows 1.7.11 installed
- `npx tsc --noEmit` passes with no errors
- `curl -X POST http://localhost:3000/api/uploads/image` with no file returns 400
- The UnlayerEditor component file exists and includes `version: '1.157.0'` in options
  </verify>
  <done>
- `react-email-editor` 1.7.11 is installed
- UnlayerEditor client component exists with dynamic import, ssr:false, onReady design loading, image upload callback, and save handler
- Image upload API route validates file type/size, uploads to Supabase Storage, returns public URL
- Unlayer engine pinned to version 1.157.0
  </done>
</task>

<task type="auto">
  <name>Task 2: Create editor page at /emails/[id]/edit and redirect from /emails/[id]</name>
  <files>src/app/(dashboard)/emails/[id]/edit/page.tsx, src/app/(dashboard)/emails/[id]/page.tsx</files>
  <action>
1. **Create `src/app/(dashboard)/emails/[id]/edit/page.tsx`** — a Server Component:

- Import `getEmailTemplate` from `@/lib/db/queries`.
- Import `env` from `@/lib/env`.
- Import `notFound` from `next/navigation`.
- Import `UnlayerEditor` from `@/components/email-editor/UnlayerEditor`.
- Get `shopId` using `new URL(env.SHOPIFY_STORE_URL).hostname`.
- Await `params` to get `id` (Next.js 15 async params pattern: `params: Promise<{ id: string }>`).
- Call `getEmailTemplate(shopId, id)`. If null, call `notFound()`.
- Render `<UnlayerEditor templateId={template.id} templateName={template.name} initialDesign={template.designJson as object | null} />`.
- This page should NOT use the dashboard sidebar layout since the editor needs full-screen width. Add a layout.tsx override if needed, or simply render the editor full-screen within the existing layout. The editor component already includes its own toolbar with Back button.

**Full page component** (keep it minimal — the UnlayerEditor handles everything):
```tsx
import { getEmailTemplate } from '@/lib/db/queries'
import { env } from '@/lib/env'
import { notFound } from 'next/navigation'
import { UnlayerEditor } from '@/components/email-editor/UnlayerEditor'

export default async function EmailEditorPage({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  const shopId = new URL(env.SHOPIFY_STORE_URL).hostname
  const template = await getEmailTemplate(shopId, id)
  if (!template) notFound()

  return (
    <UnlayerEditor
      templateId={template.id}
      templateName={template.name}
      initialDesign={template.designJson as object | null}
    />
  )
}
```

2. **Replace `src/app/(dashboard)/emails/[id]/page.tsx`** — redirect to the edit page:

Replace the entire file content with a simple redirect:
```tsx
import { redirect } from 'next/navigation'

export default async function EmailTemplateRedirect({
  params,
}: {
  params: Promise<{ id: string }>
}) {
  const { id } = await params
  redirect(`/emails/${id}/edit`)
}
```

This ensures old links to `/emails/[id]` still work by redirecting to the editor.
  </action>
  <verify>
- Visit `http://localhost:3000/emails` — click "Create New" — redirected to `/emails/{id}/edit`
- The Unlayer editor loads with the drag-and-drop interface visible
- Add some text content, click "Save Template" — no errors in console
- Navigate back to `/emails`, click "Edit" on the template card — editor opens with previously saved content restored
- Visit `/emails/{id}` (without /edit) — redirects to `/emails/{id}/edit`
- Test image upload (if Supabase email-assets bucket is configured as public): drag an image into the editor, it uploads and displays
  </verify>
  <done>
- `/emails/[id]/edit` opens the Unlayer drag-and-drop editor with full editing capabilities
- Saving persists HTML + Design JSON to the database via PUT /api/email-templates/[id]
- Reopening a saved template loads the Design JSON back into Unlayer
- `/emails/[id]` redirects to `/emails/[id]/edit`
- Image upload works when Supabase email-assets bucket is configured as public
  </done>
</task>

</tasks>

<verification>
- `react-email-editor` installed at 1.7.11
- Unlayer editor renders at `/emails/[id]/edit` without "window is not defined" errors
- Save + reopen cycle preserves the design (round-trip test)
- Image upload API returns public URL (requires Supabase email-assets bucket to be created as public — manual step)
- `npx tsc --noEmit` passes
- Engine version pinned to 1.157.0 in options (grep for it in UnlayerEditor.tsx)

**Manual setup required**: Create `email-assets` bucket as PUBLIC in Supabase Dashboard -> Storage before testing image uploads.
</verification>

<success_criteria>
- Merchants can open the Unlayer editor, design an email with drag-and-drop, save it, and reopen it with their design intact
- Images uploaded in the editor are stored in Supabase Storage and display correctly
- The editor is pinned to Unlayer engine version 1.157.0 for free-tier image upload support
</success_criteria>

<output>
After completion, create `.planning/phases/13-email-template-editor/13-02-SUMMARY.md`
</output>
