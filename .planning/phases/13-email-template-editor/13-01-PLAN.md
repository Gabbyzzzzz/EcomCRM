---
phase: 13-email-template-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/queries.ts
  - src/app/api/email-templates/route.ts
  - src/app/api/email-templates/[id]/route.ts
  - src/app/(dashboard)/emails/page.tsx
  - drizzle/0007_email_templates.sql
autonomous: true

must_haves:
  truths:
    - "/emails page shows all templates from the database as cards with placeholder thumbnail (name initial + colored background), name, last edited date"
    - "Create New button on /emails page creates a blank template and navigates to its editor"
    - "Duplicate action on a template card creates a copy with '(Copy)' suffix"
    - "Delete action on a template card removes it from the database and the list"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "emailTemplates table definition"
      contains: "emailTemplates"
    - path: "src/lib/db/queries.ts"
      provides: "CRUD query functions for email templates"
      exports: ["listEmailTemplates", "getEmailTemplate", "createEmailTemplate", "updateEmailTemplate", "deleteEmailTemplate", "duplicateEmailTemplate"]
    - path: "src/app/api/email-templates/route.ts"
      provides: "GET list + POST create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/email-templates/[id]/route.ts"
      provides: "GET one + PUT update + DELETE endpoints"
      exports: ["GET", "PUT", "DELETE"]
    - path: "src/app/(dashboard)/emails/page.tsx"
      provides: "DB-backed template list with cards, create/duplicate/delete actions"
      min_lines: 80
  key_links:
    - from: "src/app/(dashboard)/emails/page.tsx"
      to: "src/lib/db/queries.ts"
      via: "direct server component import"
      pattern: "listEmailTemplates"
    - from: "src/app/api/email-templates/route.ts"
      to: "src/lib/db/queries.ts"
      via: "query function calls"
      pattern: "createEmailTemplate"
---

<objective>
Add the `email_templates` database table, CRUD API routes, and replace the static `/emails` page with a database-backed template card list supporting Create, Duplicate, and Delete actions.

Purpose: Foundation for the Unlayer editor (Plan 02) and preset templates (Plan 03) — the schema and API must exist before templates can be edited or seeded.
Output: Working `/emails` page with empty state, "Create New" button, and card layout ready for templates.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-email-template-editor/13-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/db/index.ts
@src/lib/env.ts
@src/app/(dashboard)/emails/page.tsx
@drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emailTemplates schema, migration, and CRUD query functions</name>
  <files>src/lib/db/schema.ts, src/lib/db/queries.ts, drizzle/0007_email_templates.sql</files>
  <action>
1. **Add emailTemplates table to schema.ts** — append after the `emailClicks` table definition:

```typescript
export const emailTemplates = pgTable(
  'email_templates',
  {
    id: uuid('id').primaryKey().defaultRandom(),
    shopId: varchar('shop_id', { length: 255 }).notNull(),
    name: varchar('name', { length: 255 }).notNull(),
    html: text('html'),
    designJson: jsonb('design_json'),
    isPreset: boolean('is_preset').default(false).notNull(),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => [
    index('email_templates_shop_id_idx').on(table.shopId),
    index('email_templates_is_preset_idx').on(table.isPreset),
  ]
)
```

No FK changes to `automations.emailTemplateId` — it stays as varchar. Phase 14 will wire the linking.

2. **Generate migration** via `npx drizzle-kit generate`. Verify it produces a migration SQL file creating the `email_templates` table. Rename the generated file to `0007_email_templates.sql` if drizzle-kit names it differently. Then apply: `npx drizzle-kit push`.

3. **Add CRUD query functions to queries.ts** — import `emailTemplates` from schema and add these functions:

- `listEmailTemplates(shopId: string)`: SELECT all from `email_templates` WHERE `shop_id = shopId`, ORDER BY `is_preset DESC, updated_at DESC`. Return all rows.
- `getEmailTemplate(shopId: string, id: string)`: SELECT one by id AND shop_id. Return row or null.
- `createEmailTemplate(shopId: string, data: { name: string })`: INSERT with shopId, name, isPreset=false, html=null, designJson=null. Return the created row.
- `updateEmailTemplate(id: string, data: { name?: string; html?: string; designJson?: unknown })`: UPDATE by id, also set `updatedAt = new Date()`. Return void.
- `deleteEmailTemplate(id: string)`: DELETE by id. Return void.
- `duplicateEmailTemplate(shopId: string, id: string)`: SELECT source row by id, INSERT new row with name = `${source.name} (Copy)`, same html + designJson, isPreset=false. Return the new row.

Use the existing pattern from queries.ts — import `eq`, `and`, `desc` from drizzle-orm as needed. Type the return using Drizzle's `$inferSelect` pattern.
  </action>
  <verify>
- `npx drizzle-kit push` succeeds without errors
- `SELECT * FROM email_templates LIMIT 1;` runs without error (table exists)
- TypeScript compiles: `npx tsc --noEmit` passes with no errors related to schema or queries
  </verify>
  <done>
- `email_templates` table exists in the database with all 7 columns (id, shop_id, name, html, design_json, is_preset, created_at, updated_at)
- 6 query functions exported from queries.ts: list, get, create, update, delete, duplicate
- Migration SQL exists in drizzle/ directory
  </done>
</task>

<task type="auto">
  <name>Task 2: Create email-templates API routes and rebuild /emails list page</name>
  <files>src/app/api/email-templates/route.ts, src/app/api/email-templates/[id]/route.ts, src/app/(dashboard)/emails/page.tsx</files>
  <action>
1. **Create `src/app/api/email-templates/route.ts`** with GET and POST handlers:

- `GET`: Call `listEmailTemplates(shopId)` where shopId = `new URL(env.SHOPIFY_STORE_URL).hostname`. Return JSON array.
- `POST`: Parse body with zod schema `{ name: z.string().min(1).max(255) }`. Call `createEmailTemplate(shopId, { name })`. Return 201 with the created row as JSON. On validation error return 400.

Import `env` from `@/lib/env`, use the `getShopId()` inline pattern: `const shopId = new URL(env.SHOPIFY_STORE_URL).hostname`.

2. **Create `src/app/api/email-templates/[id]/route.ts`** with GET, PUT, DELETE:

- `GET`: Get `id` from `await params`. Call `getEmailTemplate(shopId, id)`. Return 404 if null, else return JSON.
- `PUT`: Parse body with zod schema `{ name?: z.string(), html?: z.string(), designJson?: z.unknown() }`. Call `updateEmailTemplate(id, validatedData)`. Return 200 with `{ ok: true }`.
- `DELETE`: Call `deleteEmailTemplate(id)`. Return 200 with `{ ok: true }`.

Validate `params.id` is a UUID format string before querying. Return 400 if invalid.

3. **Replace `src/app/(dashboard)/emails/page.tsx`** — this is a Server Component that:

- Calls `listEmailTemplates(shopId)` directly (no fetch needed — Server Component).
- Renders a header with title "Email Templates" and a "Create New" button.
- The "Create New" button is a Client Component (`CreateTemplateButton`) that POSTs to `/api/email-templates` with a default name "Untitled Template" and navigates to `/emails/{newId}/edit` on success using `router.push`.
- Renders a grid of template cards (`grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4`).
- Each card shows:
  - **Placeholder thumbnail**: A `div` with a colored background (use a hash of the template name to pick from a fixed palette of 6 colors: `['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']`) and the first letter of the template name in large white text, centered. Height ~120px.
  - **Name**: `font-medium` text.
  - **Last edited**: `text-xs text-muted-foreground` showing `updatedAt` as relative time (e.g., "2 hours ago") using a simple formatter — or use `toLocaleDateString()` if simpler. Include `"Preset"` badge if `isPreset=true`.
  - **Actions row**: "Edit" link to `/emails/{id}/edit`, "Duplicate" button (calls POST to duplicate endpoint), "Delete" button (calls DELETE endpoint, confirms with `window.confirm`).
- The Duplicate and Delete buttons are Client Components. Extract a `TemplateCardActions` client component that receives `templateId` and `templateName` props and handles the fetch calls + `router.refresh()` after mutation.
- If no templates exist, show an empty state: "No templates yet. Create your first template to get started."

**Color hash function** (simple, deterministic):
```typescript
function getColorForName(name: string): string {
  const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899']
  let hash = 0
  for (let i = 0; i < name.length; i++) hash = name.charCodeAt(i) + ((hash << 5) - hash)
  return colors[Math.abs(hash) % colors.length]
}
```
  </action>
  <verify>
- Visit `http://localhost:3000/emails` — page loads with "Email Templates" header and "Create New" button
- Click "Create New" — navigates to `/emails/{uuid}/edit` (404 is expected since editor page is Plan 02)
- Go back to `/emails` — the new template appears as a card with colored thumbnail showing "U" (for "Untitled Template")
- Click "Duplicate" on the card — a "(Copy)" variant appears
- Click "Delete" — confirm dialog, then card disappears
- `curl http://localhost:3000/api/email-templates` returns JSON array of templates
  </verify>
  <done>
- `/emails` page is fully DB-backed, showing template cards with colored placeholder thumbnails, name, last edited date
- Create New, Duplicate, Delete all work end-to-end
- API routes respond correctly: GET list, POST create (201), GET single, PUT update, DELETE
- Old static template list is fully replaced
  </done>
</task>

</tasks>

<verification>
- `email_templates` table exists with correct columns and indexes
- `npx tsc --noEmit` passes
- `/emails` page renders from database, not hardcoded data
- CRUD operations work via API: create, read, update, delete, duplicate
- Template cards show placeholder thumbnail with colored background + name initial
</verification>

<success_criteria>
- Visiting `/emails` shows a working, database-backed template list page
- "Create New" creates a template in the DB and redirects to the editor URL
- Duplicate creates a copy, Delete removes a template
- All 6 query functions exist and are used by the API routes
- Schema migration has been applied
</success_criteria>

<output>
After completion, create `.planning/phases/13-email-template-editor/13-01-SUMMARY.md`
</output>
