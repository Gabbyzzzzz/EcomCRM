---
phase: 14-template-automation-linking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/queries.ts
  - src/lib/automation/actions.ts
  - src/app/(dashboard)/automations/[id]/page.tsx
  - src/components/automation-detail-client.tsx
  - src/components/email-preview-panel.tsx
  - src/app/api/automations/[id]/route.ts
  - src/app/api/automations/[id]/preview/route.ts
autonomous: true

must_haves:
  truths:
    - "Automation detail page shows 'Email Template' dropdown listing all templates from email_templates table"
    - "Selecting a template from the dropdown and saving persists the linked_email_template_id UUID FK on the automation row"
    - "Send logic uses 3-tier fallback: custom_template_html -> linked email_template HTML -> React Email template (tier 3 never fails)"
    - "Template preview on automation detail page shows the currently active template (whichever tier applies)"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "linked_email_template_id, custom_template_html, custom_template_json columns on automations table"
      contains: "linkedEmailTemplateId"
    - path: "src/lib/automation/actions.ts"
      provides: "3-tier fallback logic in executeEmailAction"
      contains: "customTemplateHtml"
    - path: "src/components/automation-detail-client.tsx"
      provides: "Template selector dropdown with linked template state"
      contains: "linkedEmailTemplateId"
    - path: "src/app/api/automations/[id]/preview/route.ts"
      provides: "3-tier preview endpoint returning correct HTML tier"
      contains: "customTemplateHtml"
  key_links:
    - from: "src/components/automation-detail-client.tsx"
      to: "/api/automations/[id]"
      via: "PATCH with linkedEmailTemplateId"
      pattern: "linkedEmailTemplateId"
    - from: "src/lib/automation/actions.ts"
      to: "src/lib/db/queries.ts"
      via: "getEmailTemplate to fetch linked template HTML"
      pattern: "getEmailTemplate"
    - from: "src/app/api/automations/[id]/preview/route.ts"
      to: "src/lib/db/queries.ts"
      via: "getEmailTemplate + automation row query for 3-tier resolution"
      pattern: "customTemplateHtml|linkedEmailTemplateId"
---

<objective>
Add 3 new columns to the automations table (linked_email_template_id, custom_template_html, custom_template_json), build a template selector dropdown on the automation detail page, implement 3-tier send fallback in executeEmailAction, and update the preview endpoint to resolve the correct template tier.

Purpose: This is the core linking infrastructure. Without it, Unlayer templates created in Phase 13 cannot be used by automation flows -- they are siloed in the /emails library with no connection to the send pipeline.

Output: Automations can be linked to email_templates via UUID FK, send logic falls through 3 tiers, and the preview panel shows the correct active template.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-email-template-editor/13-01-SUMMARY.md
@.planning/phases/13-email-template-editor/13-02-SUMMARY.md

Key source files:
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/automation/actions.ts
@src/app/(dashboard)/automations/[id]/page.tsx
@src/components/automation-detail-client.tsx
@src/components/email-preview-panel.tsx
@src/app/api/automations/[id]/route.ts
@src/app/api/automations/[id]/preview/route.ts
@src/lib/email/send.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add linking columns to automations schema, migration, and PATCH endpoint updates</name>
  <files>
    src/lib/db/schema.ts
    src/lib/db/queries.ts
    src/app/api/automations/[id]/route.ts
    drizzle/0008_automation_template_linking.sql
  </files>
  <action>
1. Add 3 new columns to the `automations` pgTable in schema.ts:
   - `linkedEmailTemplateId`: uuid('linked_email_template_id').references(() => emailTemplates.id) — nullable FK to email_templates table
   - `customTemplateHtml`: text('custom_template_html') — nullable, stores flow-specific customized HTML
   - `customTemplateJson`: jsonb('custom_template_json') — nullable, stores flow-specific Unlayer design JSON

2. Write migration SQL `drizzle/0008_automation_template_linking.sql`:
   ```sql
   ALTER TABLE "automations" ADD COLUMN "linked_email_template_id" uuid REFERENCES "email_templates"("id");
   ALTER TABLE "automations" ADD COLUMN "custom_template_html" text;
   ALTER TABLE "automations" ADD COLUMN "custom_template_json" jsonb;
   ```
   Apply via postgres.js client directly (same workaround as Phase 13 — drizzle-kit push has the pg_check bug).

3. Add a query helper `getAutomationWithTemplate(shopId, automationId)` to queries.ts that returns the automation row joined with linked template data. Use a simple left join or two queries. Return type should include `linkedTemplateHtml` and `linkedTemplateDesignJson` alongside the automation row.

4. Add `listEmailTemplatesForDropdown(shopId)` to queries.ts — lightweight query returning just `{ id, name }` from email_templates, ordered by isPreset desc then name asc. This avoids sending full HTML/JSON to the client for the dropdown.

5. Update the PATCH endpoint in `src/app/api/automations/[id]/route.ts`:
   - Add `linkedEmailTemplateId` to the patchSchema as `z.string().uuid().nullable().optional()`
   - Add `customTemplateHtml` as `z.string().nullable().optional()`
   - Add `customTemplateJson` as `z.unknown().nullable().optional()`
   - Wire these into the updateSet object following the same pattern as existing fields
   - Add these fields to the `hasConfigChanges` check
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify the migration SQL is syntactically correct. Check that the PATCH endpoint accepts the new fields by reviewing the zod schema.
  </verify>
  <done>
    automations table has 3 new columns (linked_email_template_id FK, custom_template_html, custom_template_json). PATCH endpoint accepts all 3 new fields. Query helpers exist for dropdown listing and template resolution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Template selector UI, 3-tier send fallback, and preview endpoint update</name>
  <files>
    src/app/(dashboard)/automations/[id]/page.tsx
    src/components/automation-detail-client.tsx
    src/components/email-preview-panel.tsx
    src/lib/automation/actions.ts
    src/app/api/automations/[id]/preview/route.ts
  </files>
  <action>
1. **Automation detail page** (`src/app/(dashboard)/automations/[id]/page.tsx`):
   - Import `listEmailTemplatesForDropdown` from queries.ts
   - Fetch template list in the Promise.all alongside existing queries
   - Pass `templateOptions` (array of `{id, name}`) and `linkedEmailTemplateId` (from automation row) to AutomationDetailClient
   - Update the "Email Template" label in the read-only metadata section: if linkedEmailTemplateId exists, show the linked template name; if customTemplateHtml exists, show "Custom (flow-specific)"; otherwise show the legacy emailTemplateId string or 'N/A'

2. **AutomationDetailClient** (`src/components/automation-detail-client.tsx`):
   - Add props: `templateOptions: Array<{id: string, name: string}>`, `linkedEmailTemplateId: string | null`, `customTemplateHtml: string | null`
   - Add `linkedEmailTemplateId` to the form state (as a string | null field alongside existing AutomationFormValues -- extend the type or manage separately)
   - Add a template selector section ABOVE the existing config form. It should contain:
     a) A `<select>` dropdown with options: "Default (React Email)" as first option (value=""), then each template from templateOptions as `<option value={id}>{name}</option>`
     b) Current selection shows the linkedEmailTemplateId value
     c) On change, call PATCH to update linkedEmailTemplateId immediately (or track in form state and save with other changes -- prefer saving with other changes for consistency)
   - If `customTemplateHtml` exists, show a small badge "Custom edits applied" next to the dropdown
   - Pass `linkedEmailTemplateId` and `customTemplateHtml` to EmailPreviewPanel so it can show the right tier

3. **EmailPreviewPanel** (`src/components/email-preview-panel.tsx`):
   - Add props: `linkedEmailTemplateId?: string | null`, `customTemplateHtml?: string | null`
   - Update the preview fetch: POST body should now include `linkedEmailTemplateId` and `hasCustomTemplate` (boolean flag)
   - If `customTemplateHtml` is truthy, show that HTML directly in the iframe (no API call needed -- custom HTML is already rendered)
   - If `linkedEmailTemplateId` is truthy but no custom HTML, fetch preview from the updated preview endpoint with `linkedEmailTemplateId`
   - If neither, fall through to existing React Email preview (emailTemplateId string-based)
   - Show a small tier indicator label: "Custom Template", "Linked Template: {name}", or "Default Template"

4. **3-tier fallback in executeEmailAction** (`src/lib/automation/actions.ts`):
   - Import `getEmailTemplate` from queries.ts (or the new join helper)
   - Import `db` and `automations` from schema to fetch the automation row for custom template data
   - Add new logic at the TOP of executeEmailAction, BEFORE the existing switch statement:
     a) Fetch the automation row to get `customTemplateHtml`, `customTemplateJson`, `linkedEmailTemplateId`
     b) **Tier 1 check:** If `customTemplateHtml` is not null, use it directly as the HTML body. Perform variable substitution (replace `{{customer_name}}`, `{{store_name}}`, `{{unsubscribe_url}}` with actual values). Skip the React Email templateFactory entirely. Call sendMarketingEmail with a simple html string (modify sendMarketingEmail params or create a separate overload -- simplest approach: pass `templateFactory` that just returns a raw HTML wrapper, OR better: export a new `sendMarketingEmailRaw` that accepts html string instead of templateFactory).
     c) **Tier 2 check:** If `linkedEmailTemplateId` is not null, fetch the email template from email_templates table via `getEmailTemplate(shopId, linkedEmailTemplateId)`. If found and has html, use that HTML with variable substitution. Same send path as Tier 1.
     d) **Tier 3 fallback:** Existing React Email template switch/case. This is the current behavior -- no changes needed.
   - For tiers 1 and 2, create a helper function `substituteVariables(html: string, vars: Record<string, string>): string` that replaces `{{variable_name}}` patterns with actual values. Variables to support: `customer_name`, `store_name`, `unsubscribe_url`, `discount_code`, `shop_url`. These are the same variables available in React Email templates.
   - IMPORTANT: The existing `sendMarketingEmail` takes a `templateFactory: (unsubscribeUrl: string) => ReactElement`. For raw HTML tiers, modify executeEmailAction to call sendMarketingEmail differently. The cleanest approach: add an optional `rawHtml` param to `SendMarketingEmailParams`. When `rawHtml` is provided, skip the templateFactory/render step and use rawHtml directly. This minimizes changes to the existing send pipeline (tracking pixel injection, link rewriting, compliance headers all still apply).

5. **Preview endpoint update** (`src/app/api/automations/[id]/preview/route.ts`):
   - Add `linkedEmailTemplateId` and `hasCustomTemplate` to the previewSchema
   - Update the endpoint to implement 3-tier preview resolution:
     a) If `hasCustomTemplate` is true, fetch the automation row from DB and return its `customTemplateHtml`
     b) If `linkedEmailTemplateId` is provided, fetch the email template from DB via `getEmailTemplate` and return its html (with variable substitution for preview: customer_name="Preview Customer", store_name=env.RESEND_FROM_NAME, etc.)
     c) Otherwise fall through to existing React Email rendering (current switch/case)
   - Apply `substituteVariables` for tiers 1 and 2 with preview-safe values

  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors. Test the following flow mentally:
    1. Automation detail page loads with template dropdown populated from DB
    2. Selecting a template updates linkedEmailTemplateId in form state
    3. Saving persists via PATCH
    4. Preview panel shows the linked template HTML
    5. executeEmailAction resolves tiers correctly: custom > linked > React Email
  </verify>
  <done>
    Template selector dropdown appears on automation detail page with all templates from the library. Preview panel shows the correct tier's HTML. executeEmailAction uses 3-tier fallback: customTemplateHtml first, then linked email template HTML, then React Email template (always succeeds). PATCH endpoint persists the linked template ID.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` passes with zero errors
2. Schema: automations table has linked_email_template_id (UUID FK), custom_template_html (text), custom_template_json (jsonb)
3. API: PATCH /api/automations/[id] accepts linkedEmailTemplateId, customTemplateHtml, customTemplateJson
4. UI: Automation detail page shows template dropdown populated from email_templates table
5. Preview: Preview panel shows correct tier (custom > linked > default React Email)
6. Send: executeEmailAction resolves 3-tier fallback correctly
</verification>

<success_criteria>
- Automation detail page has a template selector dropdown listing all email templates
- Selecting and saving a template persists linkedEmailTemplateId as UUID FK
- Preview panel shows the currently active template based on tier priority
- executeEmailAction implements 3-tier fallback: customTemplateHtml -> linkedEmailTemplateId HTML -> React Email
- Tier 3 (React Email) always works as fallback, never fails
</success_criteria>

<output>
After completion, create `.planning/phases/14-template-automation-linking/14-01-SUMMARY.md`
</output>
