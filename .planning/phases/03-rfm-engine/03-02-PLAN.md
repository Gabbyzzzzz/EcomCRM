---
phase: 03-rfm-engine
plan: "02"
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/inngest/functions.ts
autonomous: true

must_haves:
  truths:
    - "A daily Inngest cron function calls recalculateAllRfmScores and persists updated scores + segments for all customers without manual intervention"
    - "When an orders/create or orders/updated webhook fires, the affected customer's order_count, total_spent, and last_order_at are recalculated in the same Inngest step"
    - "When any customer's segment changes during recalculation, an 'rfm/segment.changed' Inngest event is emitted containing customerId, oldSegment, and newSegment"
    - "The functions array exported from functions.ts includes the new dailyRfmRecalculation function alongside existing functions"
  artifacts:
    - path: "src/inngest/functions.ts"
      provides: "dailyRfmRecalculation cron + order-event counter updates + segment_change event emission"
      contains: "dailyRfmRecalculation"
  key_links:
    - from: "src/inngest/functions.ts"
      to: "src/lib/rfm/engine.ts"
      via: "import { recalculateAllRfmScores } from '@/lib/rfm/engine'"
      pattern: "recalculateAllRfmScores"
    - from: "src/inngest/functions.ts"
      to: "src/lib/db/queries.ts"
      via: "import { updateCustomerCountersFromOrders } from '@/lib/db/queries'"
      pattern: "updateCustomerCountersFromOrders"
    - from: "src/inngest/functions.ts"
      to: "inngest event bus"
      via: "inngest.send({ name: 'rfm/segment.changed' })"
      pattern: "rfm/segment\\.changed"
---

<objective>
Wire the RFM scoring engine into Inngest: add a daily cron that recalculates all scores, add per-order-event customer counter updates, and emit segment_change events when segments shift.

Purpose: The engine from 03-01 is a pure library. This plan makes it run automatically -- daily for full recalculation and per-event for real-time counter updates. Segment change events enable the automation engine in Phase 5.
Output: Updated `src/inngest/functions.ts` with dailyRfmRecalculation function + enhanced order webhook handler
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-rfm-engine/03-01-SUMMARY.md
@src/inngest/functions.ts
@src/inngest/client.ts
@src/lib/rfm/engine.ts
@src/lib/db/queries.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Daily RFM recalculation cron with segment change events</name>
  <files>src/inngest/functions.ts</files>
  <action>
Add a new Inngest function `dailyRfmRecalculation` to `src/inngest/functions.ts`:

```typescript
export const dailyRfmRecalculation = inngest.createFunction(
  {
    id: 'daily-rfm-recalculation',
    retries: 2,
  },
  { cron: '0 2 * * *' },  // Run at 2 AM daily
  async ({ step }) => {
    const shopId = getShopId()

    // Step 1: Recalculate all RFM scores (returns segment changes)
    const segmentChanges = await step.run('recalculate-rfm-scores', async () => {
      return await recalculateAllRfmScores(shopId)
    })

    // Step 2: Emit segment_change events for each changed customer
    if (segmentChanges.length > 0) {
      await step.run('emit-segment-changes', async () => {
        // Batch send all segment change events
        await inngest.send(
          segmentChanges.map((change) => ({
            name: 'rfm/segment.changed' as const,
            data: {
              shopId,
              customerId: change.customerId,
              oldSegment: change.oldSegment,
              newSegment: change.newSegment,
            },
          }))
        )
      })
    }

    console.log(
      `[inngest] Daily RFM recalculation complete: ${segmentChanges.length} segment changes`
    )
  }
)
```

Add import at the top:
```typescript
import { recalculateAllRfmScores } from '@/lib/rfm/engine'
```

Add `dailyRfmRecalculation` to the `functions` array at the bottom of the file. Update the comment to reflect the new count (4 functions).

IMPORTANT: Use `step.run()` to wrap each logical step. This gives Inngest checkpointing -- if the function fails after recalculation but before event emission, it won't re-run the expensive scoring query on retry.

IMPORTANT: The cron schedule `0 2 * * *` runs at 2 AM UTC daily. This satisfies RFM-05.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Grep for:
1. `dailyRfmRecalculation` is defined and in the functions array
2. `recalculateAllRfmScores` is imported from `@/lib/rfm/engine`
3. `rfm/segment.changed` event name appears in an `inngest.send()` call
4. `cron: '0 2 * * *'` schedule is set
  </verify>
  <done>
`dailyRfmRecalculation` Inngest function runs at 2 AM daily, calls `recalculateAllRfmScores(shopId)`, and emits `rfm/segment.changed` events for every customer whose segment changed. The function is registered in the exported functions array.
  </done>
</task>

<task type="auto">
  <name>Task 2: Per-order customer counter update in webhook handler</name>
  <files>src/inngest/functions.ts</files>
  <action>
Modify the existing `processShopifyWebhook` function's `orders/create` and `orders/updated` cases to also update the affected customer's counters after upserting the order.

In the `orders/create` and `orders/updated` case block, AFTER the existing `upsertOrder()` call, add:

```typescript
// RFM-04: Recalculate customer counters from orders table
// The order payload contains the customer GID -- resolve to internal UUID
if (order.customer?.id) {
  const { db: database } = await import('@/lib/db')
  const { customers: customersTable } = await import('@/lib/db/schema')
  const { eq, and } = await import('drizzle-orm')

  const [customerRow] = await database
    .select({ id: customersTable.id })
    .from(customersTable)
    .where(
      and(
        eq(customersTable.shopId, shopId),
        eq(customersTable.shopifyId, order.customer.id)
      )
    )
    .limit(1)

  if (customerRow) {
    await updateCustomerCountersFromOrders(shopId, customerRow.id)
  }
}
```

Add the import at the top of the file:
```typescript
import { updateCustomerCountersFromOrders } from '@/lib/db/queries'
```

Also update the `ShopifyOrder` type usage -- the order payload from Shopify webhooks includes a `customer` field with `id` (the customer GID). Check `src/lib/shopify/types.ts` to see if the `ShopifyOrder` type already has a `customer` field. If not, the import should be adjusted: cast `order` to include `customer?: { id: string }` inline, e.g.:
```typescript
const orderWithCustomer = payload as ShopifyOrder & { customer?: { id: string } }
```

This handles the case where the Shopify order webhook payload includes the customer reference. Use the `customer.id` (which is the Shopify GID like `gid://shopify/Customer/123`) to look up the internal UUID, then call `updateCustomerCountersFromOrders`.

IMPORTANT: This does NOT run full RFM quintile recalculation per event (that would be expensive). It only updates the aggregate counters (order_count, total_spent, last_order_at) for the single affected customer. Full NTILE recalculation happens in the daily cron only.

IMPORTANT: Do not remove or modify any existing logic in the switch cases. Only ADD the counter update after the existing upsertOrder call.

IMPORTANT: Keep the existing dynamic imports pattern (`await import(...)`) used in the bulk_operations/finish case for consistency, OR use static imports at the top if that is cleaner. Since we're adding a static import for `updateCustomerCountersFromOrders` anyway, consider converting the customer lookup to use the already-imported `db` and schema. But note the current file uses dynamic imports in the bulk case -- for the order cases, static imports are fine since they always run (not conditional like bulk).

Actually, to keep things simple: add static imports at the top for `db`, `customers` (schema), `eq`, `and` since these are now used in the common order path. Then also simplify the bulk_operations/finish case to use the same static imports instead of dynamic ones. This reduces code and avoids the repeated `await import()` pattern.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Grep for:
1. `updateCustomerCountersFromOrders` is called in the orders/create case
2. The import for `updateCustomerCountersFromOrders` exists
3. `order.customer` or `orderWithCustomer.customer` pattern appears
4. No `parseFloat` anywhere in functions.ts
  </verify>
  <done>
When an orders/create or orders/updated webhook arrives, the affected customer's order_count, total_spent, avg_order_value, first_order_at, and last_order_at are recalculated from the orders table within the same Inngest step. The full RFM quintile recalculation is NOT triggered per-event (daily cron handles that).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep "dailyRfmRecalculation" src/inngest/functions.ts` confirms the cron function exists
3. `grep "rfm/segment.changed" src/inngest/functions.ts` confirms segment change events are emitted
4. `grep "updateCustomerCountersFromOrders" src/inngest/functions.ts` confirms per-order counter updates
5. `grep "recalculateAllRfmScores" src/inngest/functions.ts` confirms the engine is called from the cron
6. The `functions` array includes `dailyRfmRecalculation` alongside existing 3 functions (now 4 total)
7. `grep "parseFloat" src/inngest/functions.ts` returns zero matches (money safety check)
</verification>

<success_criteria>
- Daily Inngest cron at 2 AM calls recalculateAllRfmScores for full quintile recalculation
- Segment changes from daily recalculation emit rfm/segment.changed events consumable by Phase 5 automation
- Order webhook handler updates affected customer's counters from orders table in real-time
- All 4 Inngest functions registered in the exported functions array
- TypeScript compiles with no errors
- No parseFloat anywhere in the file
</success_criteria>

<output>
After completion, create `.planning/phases/03-rfm-engine/03-02-SUMMARY.md`
</output>
