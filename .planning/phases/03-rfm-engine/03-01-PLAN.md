---
phase: 03-rfm-engine
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/rfm/engine.ts
  - src/lib/db/queries.ts
autonomous: true

must_haves:
  truths:
    - "recalculateAllRfmScores runs a single SQL statement with NTILE(5) OVER window functions for R, F, and M -- no customer rows are loaded into Node.js for sorting"
    - "Every customer row receives rfm_r, rfm_f, rfm_m scores (integers 1-5) and a segment label from the 7-value enum after recalculation"
    - "mapRfmToSegment maps all 125 possible (R,F,M) score combinations to exactly one of: champion, loyal, potential, new, at_risk, hibernating, lost"
    - "updateCustomerCountersFromOrders recalculates a single customer's order_count, total_spent, avg_order_value, first_order_at, and last_order_at from the orders table using Decimal arithmetic"
  artifacts:
    - path: "src/lib/rfm/engine.ts"
      provides: "RFM scoring engine with PostgreSQL NTILE(5) and segment mapping"
      exports: ["recalculateAllRfmScores", "mapRfmToSegment", "SEGMENT_MAP"]
    - path: "src/lib/db/queries.ts"
      provides: "updateCustomerCountersFromOrders query function"
      contains: "updateCustomerCountersFromOrders"
  key_links:
    - from: "src/lib/rfm/engine.ts"
      to: "src/lib/db/index.ts"
      via: "import { db } from '@/lib/db'"
      pattern: "db\\.execute\\(sql"
    - from: "src/lib/rfm/engine.ts"
      to: "src/lib/db/schema.ts"
      via: "import { customers } from '@/lib/db/schema'"
      pattern: "customers\\.segment|customers\\.rfmR"
---

<objective>
Create the RFM scoring engine that computes quintile-based R/F/M scores via PostgreSQL NTILE(5) window functions and maps score combinations to 7 named customer segments. Also add the per-customer counter recalculation query used by order events.

Purpose: This is the core scoring module that Phase 3's Inngest cron and webhook handlers will call. Without it, no customer can be segmented.
Output: `src/lib/rfm/engine.ts` (scoring + segment mapping), updated `src/lib/db/queries.ts` (customer counter recalculation)
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/db/schema.ts
@src/lib/db/index.ts
@src/lib/db/queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RFM scoring engine with NTILE(5) and segment mapping</name>
  <files>src/lib/rfm/engine.ts</files>
  <action>
Create `src/lib/rfm/engine.ts` with the following exports:

1. **`SEGMENT_MAP`** -- a readonly Record mapping RFM score patterns to segment labels. Use this mapping logic (inspired by standard RFM segmentation):

| Pattern | Segment |
|---------|---------|
| R >= 4, F >= 4, M >= 4 | champion |
| R >= 3, F >= 3, M >= 3 | loyal |
| R >= 3, F >= 1, M >= 1 (but not loyal/champion) | potential |
| R >= 4, F <= 1 | new |
| R <= 2, F >= 2 | at_risk |
| R <= 2, F <= 2, M >= 2 | hibernating |
| R <= 1 (everything else) | lost |

Implement as a pure function `mapRfmToSegment(r: number, f: number, m: number): CustomerSegment` that evaluates conditions in priority order (champion first, lost last as default). Return type is the union type matching the `customerSegmentEnum` values: `'champion' | 'loyal' | 'potential' | 'new' | 'at_risk' | 'hibernating' | 'lost'`.

2. **`recalculateAllRfmScores(shopId: string): Promise<SegmentChange[]>`** -- the main scoring function:

   a. Execute a SINGLE raw SQL query via `db.execute(sql`...`)` that:
      - Selects from `customers` WHERE `shop_id = ${shopId}` AND `deleted_at IS NULL`
      - Computes `NTILE(5) OVER (ORDER BY last_order_at DESC NULLS LAST)` as `rfm_r` (more recent = higher score)
      - Computes `NTILE(5) OVER (ORDER BY order_count ASC NULLS LAST)` as `rfm_f` (more orders = higher score)
      - Computes `NTILE(5) OVER (ORDER BY total_spent ASC NULLS LAST)` as `rfm_m` (more spent = higher score)
      - Returns `id`, `rfm_r`, `rfm_f`, `rfm_m`, and the CURRENT `segment` column (as `old_segment`)
      - Handle edge case: customers with NULL `last_order_at` or `order_count = 0` should get lowest scores (NULLS LAST in DESC = bottom quintile, NULLS LAST in ASC = bottom quintile -- this is correct for R but needs NULLS FIRST for F and M since ASC with NULLS LAST would put nulls at top. Use `ORDER BY order_count ASC NULLS FIRST` and `ORDER BY total_spent::numeric ASC NULLS FIRST` so NULL/zero values get quintile 1)

   b. For each row returned, call `mapRfmToSegment(r, f, m)` to compute the new segment label.

   c. Batch-update all customer rows using a single SQL UPDATE with a VALUES list (or use individual Drizzle updates in a transaction if the batch approach is too complex). Update `rfm_r`, `rfm_f`, `rfm_m`, and `segment` columns.

   Recommended approach: Use a CTE-based UPDATE that computes the NTILE scores and new segments in one statement, then updates in place. If Drizzle's `sql` template doesn't support this cleanly, use a two-step approach:
   - Step 1: SELECT with NTILE to get scores
   - Step 2: UPDATE each customer's rfm_r, rfm_f, rfm_m, segment in a single batched UPDATE statement using `CASE WHEN id = ... THEN ...` or loop with Promise.all in chunks of 100

   d. Collect and return an array of `SegmentChange` objects for customers whose segment actually changed: `{ customerId: string, oldSegment: string | null, newSegment: string }`.

3. **Type definitions** at the top of the file:
   ```typescript
   export type CustomerSegment = 'champion' | 'loyal' | 'potential' | 'new' | 'at_risk' | 'hibernating' | 'lost'

   export interface SegmentChange {
     customerId: string
     oldSegment: string | null
     newSegment: CustomerSegment
   }
   ```

Import `db` from `@/lib/db`, `sql` from `drizzle-orm`, and `customers` from `@/lib/db/schema`.

IMPORTANT: The NTILE window function MUST run in PostgreSQL, not in application memory. Do NOT load all customers into a JS array and sort them. The whole point of RFM-01 is that scoring happens in the database.

IMPORTANT: For the NTILE ordering:
- Recency (R): `ORDER BY last_order_at DESC NULLS LAST` -- most recent gets quintile 5 (highest)
- Frequency (F): `ORDER BY order_count ASC NULLS FIRST` -- most orders gets quintile 5 (highest). NULLS FIRST ensures NULL/0 customers are in quintile 1.
- Monetary (M): `ORDER BY total_spent::numeric ASC NULLS FIRST` -- highest spenders get quintile 5. Cast to numeric for proper ordering. NULLS FIRST ensures NULL customers are in quintile 1.

Wait -- NTILE(5) assigns quintile 1 to the first rows in the ordered set. So:
- R: `ORDER BY last_order_at DESC NULLS LAST` means most recent customers get quintile 1. We want most recent = score 5. So use `ORDER BY last_order_at ASC NULLS FIRST` to put old/null customers in quintile 1 (low score) and recent customers in quintile 5 (high score).
- F: `ORDER BY order_count ASC NULLS FIRST` means low-order customers get quintile 1 (low score), high-order get quintile 5 (high score). Correct.
- M: `ORDER BY total_spent::numeric ASC NULLS FIRST` means low-spend customers get quintile 1, high-spend get quintile 5. Correct.

Use these orderings. NTILE(5) produces 1-5 where 1 = first partition of the ordered set.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Grep the file to confirm:
1. `NTILE(5)` appears in a SQL template literal (not application code sorting)
2. `mapRfmToSegment` function exists and returns one of the 7 segment values
3. No `parseFloat` anywhere in the file
4. `db.execute(sql` is used for the window function query
  </verify>
  <done>
`src/lib/rfm/engine.ts` exports `recalculateAllRfmScores`, `mapRfmToSegment`, `SEGMENT_MAP`, `CustomerSegment`, and `SegmentChange`. The NTILE(5) scoring runs entirely in PostgreSQL. All 125 R/F/M combinations map to exactly one of 7 segments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Customer counter recalculation query</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Add a new exported function to `src/lib/db/queries.ts`:

**`updateCustomerCountersFromOrders(shopId: string, customerInternalId: string): Promise<void>`**

This function recalculates a customer's aggregate fields directly from the orders table:
- Query the `orders` table for all orders WHERE `customer_id = customerInternalId` AND `shop_id = shopId`
- Compute: `COUNT(*)` as orderCount, `SUM(total_price::numeric)` as totalSpent (using SQL aggregation, NOT loading rows into JS), `MIN(shopify_created_at)` as firstOrderAt, `MAX(shopify_created_at)` as lastOrderAt
- Calculate avgOrderValue: if orderCount > 0, totalSpent / orderCount (use Decimal in JS after getting the SQL result, or compute in SQL as `SUM(total_price::numeric) / COUNT(*)`)
- Update the customer row with these values

Use Drizzle's `sql` tagged template for the aggregate query, then a standard Drizzle `.update()` for the customer row. Use `Decimal` for the avgOrderValue computation (per project convention -- never parseFloat).

Also add the required imports at the top if not already present: `sql` from `drizzle-orm`.

Do NOT modify any existing functions in queries.ts. Only ADD the new function at the bottom of the file (before the closing section if any).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Grep queries.ts for:
1. `updateCustomerCountersFromOrders` export exists
2. `SUM` or `COUNT` appears in a SQL context (aggregation happens in DB)
3. `Decimal` is used for money computation
4. No `parseFloat` in the new function
  </verify>
  <done>
`updateCustomerCountersFromOrders` is exported from queries.ts. It recalculates order_count, total_spent, avg_order_value, first_order_at, and last_order_at for a single customer using SQL aggregation + Decimal arithmetic. Existing query functions are unmodified.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -r "NTILE" src/lib/rfm/engine.ts` returns matches inside sql template literals
3. `grep -r "parseFloat" src/lib/rfm/ src/lib/db/queries.ts` returns NO matches
4. `grep "mapRfmToSegment" src/lib/rfm/engine.ts` confirms the function is exported
5. `grep "updateCustomerCountersFromOrders" src/lib/db/queries.ts` confirms the function is exported
</verification>

<success_criteria>
- RFM scoring engine exists at src/lib/rfm/engine.ts with NTILE(5) window functions in PostgreSQL
- All 7 segments are mapped from R/F/M score combinations
- Customer counter recalculation query exists and uses SQL aggregation + Decimal
- TypeScript compiles with no errors
- Zero instances of parseFloat in RFM or query code
</success_criteria>

<output>
After completion, create `.planning/phases/03-rfm-engine/03-01-SUMMARY.md`
</output>
