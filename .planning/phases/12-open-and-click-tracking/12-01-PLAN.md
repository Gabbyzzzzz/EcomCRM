---
phase: 12-open-and-click-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/queries.ts
  - src/app/api/track/open/route.ts
  - src/app/api/track/click/route.ts
  - drizzle/*.sql
autonomous: true

must_haves:
  truths:
    - "GET /api/track/open?id=xxx returns a 1x1 transparent GIF and records opened_at on the message_logs row"
    - "GET /api/track/click?id=xxx&url=yyy records click to email_clicks table then 302 redirects to the real URL"
    - "email_clicks table exists with message_log_id FK, link_url, and clicked_at columns"
    - "First click on a message also updates clicked_at on the parent message_logs row"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "email_clicks table definition with indexes"
      contains: "emailClicks"
    - path: "src/app/api/track/open/route.ts"
      provides: "Tracking pixel endpoint"
      exports: ["GET"]
    - path: "src/app/api/track/click/route.ts"
      provides: "Click redirect endpoint"
      exports: ["GET"]
    - path: "src/lib/db/queries.ts"
      provides: "recordEmailOpen and recordEmailClick functions"
      contains: "recordEmailOpen"
  key_links:
    - from: "src/app/api/track/open/route.ts"
      to: "src/lib/db/queries.ts"
      via: "recordEmailOpen function call"
      pattern: "recordEmailOpen"
    - from: "src/app/api/track/click/route.ts"
      to: "src/lib/db/queries.ts"
      via: "recordEmailClick function call"
      pattern: "recordEmailClick"
    - from: "src/lib/db/schema.ts"
      to: "src/lib/db/queries.ts"
      via: "emailClicks table import"
      pattern: "emailClicks"
---

<objective>
Create the email_clicks table schema, the open-tracking pixel endpoint, and the click-redirect endpoint. These are the data layer and API surface for email engagement tracking.

Purpose: Provide the backend infrastructure that Plan 02 will wire into the email send pipeline and UI.
Output: email_clicks table, GET /api/track/open, GET /api/track/click, query helper functions.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email_clicks table to Drizzle schema and create tracking query helpers</name>
  <files>src/lib/db/schema.ts, src/lib/db/queries.ts</files>
  <action>
1. In `src/lib/db/schema.ts`, add a new `emailClicks` table:
   - `id`: uuid PK defaultRandom
   - `shopId`: varchar(255) NOT NULL
   - `messageLogId`: uuid NOT NULL, FK to messageLogs.id
   - `linkUrl`: text NOT NULL (the original destination URL that was clicked)
   - `clickedAt`: timestamp with timezone, defaultNow, NOT NULL
   - Indexes: on shopId, on messageLogId, on clickedAt
   Import this table at the top with the existing imports.

2. In `src/lib/db/queries.ts`, add two new exported async functions:

   a) `recordEmailOpen(messageLogId: string)`:
      - UPDATE message_logs SET opened_at = NOW(), status = 'opened' WHERE id = messageLogId AND opened_at IS NULL
      - Use Drizzle query builder: `db.update(messageLogs).set({ openedAt: new Date(), status: 'opened' }).where(and(eq(messageLogs.id, messageLogId), isNull(messageLogs.openedAt)))`
      - The `AND opened_at IS NULL` condition ensures idempotency — only the first open is recorded.
      - Wrap in try/catch, log error but never throw (tracking is best-effort).

   b) `recordEmailClick(shopId: string, messageLogId: string, linkUrl: string)`:
      - INSERT into emailClicks: { shopId, messageLogId, linkUrl }
      - Also UPDATE message_logs SET clicked_at = NOW(), status = 'clicked' WHERE id = messageLogId AND clicked_at IS NULL (first click updates parent row)
      - Use a single async function with two sequential queries (insert click, then update parent).
      - Wrap in try/catch, log error but never throw.
      - Import `emailClicks` from schema at the top of queries.ts.

   Add `emailClicks` to the existing import from './schema' in queries.ts.

3. **Run Drizzle migration generation and apply:**
   - Run `npx drizzle-kit generate` to produce a new migration SQL file in `./drizzle/` for the emailClicks table.
   - Verify a new migration SQL file was created (e.g., `drizzle/0006_*.sql`) containing `CREATE TABLE "email_clicks"`.
   - Run `npx drizzle-kit migrate` to apply the migration to the database so the email_clicks table actually exists.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors. Visually confirm emailClicks table has correct columns, FK, and indexes. Confirm both query functions use Drizzle builder (no raw SQL) and handle errors gracefully. Verify a new migration file exists in `drizzle/` (e.g., `drizzle/0006_*.sql`) containing `CREATE TABLE "email_clicks"`. Run `npx drizzle-kit migrate` and confirm it completes without errors (table exists in database).
  </verify>
  <done>
    email_clicks table defined in schema.ts with uuid PK, shopId, messageLogId FK, linkUrl, clickedAt. Migration SQL file generated in drizzle/ and applied — email_clicks table exists in the database. Two query functions (recordEmailOpen, recordEmailClick) exist in queries.ts, both idempotent and non-throwing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tracking pixel and click-redirect API endpoints</name>
  <files>src/app/api/track/open/route.ts, src/app/api/track/click/route.ts</files>
  <action>
1. Create `src/app/api/track/open/route.ts`:
   - Export a `GET` handler that:
     a) Reads `id` from `request.nextUrl.searchParams` (this is the message_log UUID).
     b) If `id` is missing or not a valid UUID format (use a simple regex: `/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i`), return the pixel anyway (no error — tracking is invisible to user).
     c) If `id` is present and valid, call `recordEmailOpen(id)` from `@/lib/db/queries` (fire-and-forget — no await needed since we don't want to delay the pixel response, BUT to be safe for serverless, do await it since the function is best-effort and fast).
     d) Return a `new Response(TRANSPARENT_GIF, { status: 200, headers: { 'Content-Type': 'image/gif', 'Cache-Control': 'no-store, no-cache, must-revalidate, max-age=0' } })`.
     e) The `TRANSPARENT_GIF` is a 1x1 transparent GIF as a `Uint8Array`. Use this exact byte sequence:
        `new Uint8Array([0x47,0x49,0x46,0x38,0x39,0x61,0x01,0x00,0x01,0x00,0x80,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x00,0x21,0xf9,0x04,0x01,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x02,0x02,0x44,0x01,0x00,0x3b])`
   - Add `export const dynamic = 'force-dynamic'` to prevent Next.js from caching this route.
   - Add `export const runtime = 'nodejs'` (needed for DB access).

2. Create `src/app/api/track/click/route.ts`:
   - Export a `GET` handler that:
     a) Reads `id` (message_log UUID) and `url` (original destination URL) from `request.nextUrl.searchParams`.
     b) Validate `url`: must start with `http://` or `https://`. If missing or invalid, redirect to APP_URL from env as a fallback (import `env` from `@/lib/env`).
     c) Validate `id`: if missing or not a valid UUID format, skip recording but still redirect to `url`.
     d) If both are valid, derive `shopId` from `env.SHOPIFY_STORE_URL` hostname (same pattern as elsewhere: `new URL(env.SHOPIFY_STORE_URL).hostname`), then call `await recordEmailClick(shopId, id, url)`.
     e) Return `NextResponse.redirect(url, 302)`.
   - Important: use `NextResponse.redirect()` from `next/server`, NOT `Response.redirect()` — Next.js prefers its own wrapper.
   - Add `export const dynamic = 'force-dynamic'`.
   - Add `export const runtime = 'nodejs'`.
  </action>
  <verify>
    Run `npx tsc --noEmit` — no type errors. Both route files export GET. The open endpoint returns image/gif with no-cache headers. The click endpoint does a 302 redirect. Both handle missing/invalid params gracefully without errors.
  </verify>
  <done>
    GET /api/track/open?id=xxx returns 1x1 transparent GIF and records open. GET /api/track/click?id=xxx&url=yyy records click and 302 redirects. Both endpoints are idempotent and non-throwing.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors.
2. `emailClicks` table in schema.ts has: id (uuid PK), shopId, messageLogId (FK to messageLogs), linkUrl (text), clickedAt (timestamp).
3. `recordEmailOpen` in queries.ts updates opened_at only when currently NULL (idempotent).
4. `recordEmailClick` in queries.ts inserts into emailClicks and updates clicked_at on parent messageLogs row.
5. `/api/track/open` route exports GET, returns image/gif with Cache-Control no-store.
6. `/api/track/click` route exports GET, validates URL starts with http(s), returns 302 redirect.
7. Both endpoints handle missing/invalid params without throwing.
</verification>

<success_criteria>
- email_clicks table defined and compiles
- Both tracking endpoints exist and type-check
- All query functions are idempotent and non-throwing
- TypeScript strict compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-open-and-click-tracking/12-01-SUMMARY.md`
</output>
