---
phase: 06-dashboard-and-customer-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/queries.ts
  - src/app/(dashboard)/page.tsx
  - src/components/segment-chart.tsx
  - src/components/revenue-chart.tsx
autonomous: true

must_haves:
  truths:
    - "Dashboard loads 4 KPI cards (total customers, total revenue, new customers 30d, emails sent 30d) with live DB data"
    - "Segment distribution chart renders a bar or donut showing count per segment from the database"
    - "Revenue over time chart renders a line chart of daily revenue for the last 90 days"
    - "Churn alert widget shows count and names of customers who moved to at_risk/hibernating/lost in last 7 days"
    - "Recent activity feed shows latest automation sends and order events in reverse chronological order"
  artifacts:
    - path: "src/lib/db/queries.ts"
      provides: "Dashboard query functions"
      contains: "getDashboardKpis"
    - path: "src/app/(dashboard)/page.tsx"
      provides: "Dashboard page with all widgets"
      contains: "DashboardPage"
    - path: "src/components/segment-chart.tsx"
      provides: "Recharts segment distribution chart"
      contains: "SegmentChart"
    - path: "src/components/revenue-chart.tsx"
      provides: "Recharts revenue line chart"
      contains: "RevenueChart"
  key_links:
    - from: "src/app/(dashboard)/page.tsx"
      to: "src/lib/db/queries.ts"
      via: "server-side query calls"
      pattern: "getDashboardKpis|getSegmentDistribution|getRevenueOverTime|getChurnAlerts|getRecentActivity"
    - from: "src/app/(dashboard)/page.tsx"
      to: "src/components/segment-chart.tsx"
      via: "client component import"
      pattern: "SegmentChart"
    - from: "src/app/(dashboard)/page.tsx"
      to: "src/components/revenue-chart.tsx"
      via: "client component import"
      pattern: "RevenueChart"
---

<objective>
Build the main CRM dashboard with KPI cards, segment distribution chart, revenue over time chart, churn alert widget, and recent activity feed — all reading live data from the database.

Purpose: This is the primary CRM interface — the first thing users see. It surfaces the most important metrics and alerts at a glance.
Output: A fully data-driven dashboard page replacing the current placeholder.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/app/(dashboard)/page.tsx
@src/app/(dashboard)/layout.tsx
@src/lib/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dashboard query functions to queries.ts</name>
  <files>src/lib/db/queries.ts</files>
  <action>
Add the following query functions to the bottom of `src/lib/db/queries.ts`. All use Drizzle query builder (no raw SQL unless aggregation requires it). shopId is always the first parameter.

1. **getDashboardKpis(shopId: string)** — Returns an object with:
   - `totalCustomers`: COUNT from customers where shopId matches and deletedAt is NULL
   - `totalRevenue`: SUM(total_price) from orders where shopId matches — use Decimal, return as string
   - `newCustomers30d`: COUNT from customers where createdAt >= 30 days ago and deletedAt is NULL
   - `emailsSent30d`: COUNT from message_logs where status = 'sent' and sentAt >= 30 days ago
   Use `db.execute<T>()` with a single SQL query joining counts via subqueries for efficiency. Return type: `{ totalCustomers: number; totalRevenue: string; newCustomers30d: number; emailsSent30d: number }`.

2. **getSegmentDistribution(shopId: string)** — Returns array of `{ segment: string; count: number }`. Query: SELECT segment, COUNT(*) FROM customers WHERE shop_id = $1 AND deleted_at IS NULL AND segment IS NOT NULL GROUP BY segment. Use `db.execute<T>()`.

3. **getRevenueOverTime(shopId: string, days: number = 90)** — Returns array of `{ date: string; revenue: string }`. Query: SELECT DATE(shopify_created_at) as date, SUM(total_price) as revenue FROM orders WHERE shop_id = $1 AND shopify_created_at >= NOW() - interval '$days days' GROUP BY DATE(shopify_created_at) ORDER BY date ASC. Use `db.execute<T>()`. The `days` parameter should be interpolated safely via `sql` template literal. Return revenue as string (Decimal-safe).

4. **getChurnAlerts(shopId: string, days: number = 7)** — Returns array of `{ id: string; name: string | null; email: string | null; segment: string }`. Query customers where segment IN ('at_risk', 'hibernating', 'lost') AND shopify_updated_at >= NOW() - interval '$days days' AND deletedAt IS NULL. Use Drizzle query builder with `inArray` for segments. Limit 20. Order by shopifyUpdatedAt desc.

   NOTE: This is an approximation — ideally we would track segment_change events in a dedicated table. For now, using shopifyUpdatedAt as a proxy for "recently changed" is acceptable. The daily RFM cron updates customers, so recently-updated customers in churn segments are likely recent transitions.

5. **getRecentActivity(shopId: string, limit: number = 20)** — Returns two arrays:
   - Recent message logs: SELECT id, customer_id, subject, status, sent_at FROM message_logs WHERE shop_id = $1 ORDER BY sent_at DESC LIMIT $limit. Join with customers to get customer name.
   - Recent orders: SELECT id, customer_id, total_price, shopify_created_at FROM orders WHERE shop_id = $1 ORDER BY shopify_created_at DESC LIMIT $limit.

   Return type: `{ messages: Array<{ id: string; customerName: string | null; subject: string | null; status: string; sentAt: Date | null }>; orders: Array<{ id: string; customerName: string | null; totalPrice: string | null; createdAt: Date | null }> }`.

   Use Drizzle's leftJoin to join messageLogs/orders with customers on customerId. Import `leftJoin` pattern: `db.select({...}).from(messageLogs).leftJoin(customers, eq(messageLogs.customerId, customers.id))`.

All interfaces for return types should be exported.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors in queries.ts</verify>
  <done>Five new exported query functions exist in queries.ts, all using Drizzle query builder, all returning typed results</done>
</task>

<task type="auto">
  <name>Task 2: Create Recharts chart components (segment + revenue)</name>
  <files>src/components/segment-chart.tsx, src/components/revenue-chart.tsx</files>
  <action>
Create two Client Components that wrap Recharts charts. Both must have `'use client'` at the top.

**src/components/segment-chart.tsx** — `SegmentChart`
- Props: `{ data: Array<{ segment: string; count: number }> }`
- Render a Recharts `BarChart` (or `PieChart` — prefer BarChart for readability) showing count per segment.
- Use `ResponsiveContainer` with width="100%" height={300}.
- Import from 'recharts': `BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, CartesianGrid`.
- Bar fill color: use a color map for segments: champion=#22c55e, loyal=#3b82f6, potential=#a855f7, new=#06b6d4, at_risk=#f59e0b, hibernating=#f97316, lost=#ef4444.
- Each bar should use the segment color. Use Recharts `Cell` component to color individual bars.
- XAxis dataKey="segment", capitalize labels. YAxis shows count.
- Tooltip shows segment name + count.
- No legend needed (colors are self-explanatory with labeled x-axis).

**src/components/revenue-chart.tsx** — `RevenueChart`
- Props: `{ data: Array<{ date: string; revenue: string }> }`
- Render a Recharts `LineChart` showing revenue over time.
- Use `ResponsiveContainer` with width="100%" height={300}.
- Import from 'recharts': `LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer, CartesianGrid`.
- Line stroke="#3b82f6" (blue), strokeWidth=2.
- XAxis dataKey="date", format dates as MM/DD. Use a custom tickFormatter.
- YAxis formats as currency (prepend $, abbreviate thousands as K). Use a custom tickFormatter.
- Tooltip shows date + formatted revenue.
- CartesianGrid with strokeDasharray="3 3".

Both components should handle empty data gracefully — show a centered "No data" message if array is empty.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify both files export their components.</verify>
  <done>Two client chart components exist, both using Recharts with ResponsiveContainer, both handling empty data gracefully</done>
</task>

<task type="auto">
  <name>Task 3: Replace dashboard placeholder with data-driven page</name>
  <files>src/app/(dashboard)/page.tsx</files>
  <action>
Replace the current placeholder dashboard page with a Server Component that fetches all dashboard data and renders 5 widgets.

**Imports:**
- `getDashboardKpis`, `getSegmentDistribution`, `getRevenueOverTime`, `getChurnAlerts`, `getRecentActivity` from `@/lib/db/queries`
- `env` from `@/lib/env`
- `SegmentChart` from `@/components/segment-chart`
- `RevenueChart` from `@/components/revenue-chart`
- `Link` from `next/link`

**Data fetching:**
- Derive `shopId` from `new URL(env.SHOPIFY_STORE_URL).hostname`
- Call all 5 query functions in parallel using `Promise.all([...])` at the top of the component

**Layout — use Tailwind grid:**

1. **KPI Cards row** — 4 cards in a responsive grid (`grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4`). Each card:
   - Uses a `<div>` with classes `rounded-lg border bg-card p-6`
   - Shows label (small muted text), value (text-2xl font-semibold), and a subtle icon or color accent
   - Total Customers: format as number with toLocaleString()
   - Total Revenue: format as $X,XXX.XX using Decimal for formatting (import Decimal from 'decimal.js')
   - New Customers (30d): number
   - Emails Sent (30d): number

2. **Charts row** — 2 charts side by side (`grid grid-cols-1 lg:grid-cols-2 gap-4`):
   - Left: Segment Distribution — `<div className="rounded-lg border bg-card p-6">` with heading "Segment Distribution" + `<SegmentChart data={segmentData} />`
   - Right: Revenue Over Time — same card wrapper + heading "Revenue (Last 90 Days)" + `<RevenueChart data={revenueData} />`

3. **Churn Alert Widget** — Full width card:
   - Heading: "Churn Alerts" with a count badge (e.g., "3 customers")
   - If empty: "No churn alerts in the last 7 days"
   - If not empty: List customer names with segment badges (use colored badge per segment: at_risk=yellow, hibernating=orange, lost=red). Each name links to `/customers/${id}`.
   - Limit display to 10 items, show "+N more" if truncated.

4. **Recent Activity Feed** — Full width card:
   - Heading: "Recent Activity"
   - Merge messages and orders into a single timeline sorted by date descending (sentAt for messages, createdAt for orders). Take the most recent 15 combined.
   - Each item shows: icon/type indicator (email icon for messages, cart icon for orders), description ("Sent 'Welcome!' to John Doe" or "Order $149.99 by Jane Smith"), and relative time.
   - Use simple text indicators, not actual SVG icons (e.g., "[Email]" prefix or "[Order]" prefix). This keeps it Server-Component-compatible.
   - Format times as relative ("2 hours ago", "3 days ago") using a simple helper function that computes the difference from now.

**Page metadata:**
```typescript
export const metadata = { title: 'Dashboard | EcomCRM' }
```

The page must remain a Server Component — charts are the only Client Components (passed data as props).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Run `npm run build` or check that the page compiles. Visually: the page should show 4 KPI cards, 2 charts, churn alerts, and activity feed.</verify>
  <done>Dashboard page renders all 5 widgets (KPIs, segment chart, revenue chart, churn alerts, activity feed) with live database data. Page is a Server Component; only charts are Client Components.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Dashboard page loads at `/` with all 5 widgets visible
3. KPI cards show real numbers from the database (or zeros if DB is empty)
4. Segment chart renders bars for each segment present in the DB
5. Revenue chart renders a line for the last 90 days of order data
6. Churn alerts section shows customers in at_risk/hibernating/lost segments
7. Activity feed merges message logs and orders in reverse chronological order
</verification>

<success_criteria>
- Dashboard page replaces placeholder with 4 KPI cards, 2 Recharts charts, churn widget, and activity feed
- All data comes from live database queries (no hardcoded/mock data)
- Page is a Server Component; chart components are Client Components
- TypeScript strict — no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard-and-customer-ui/06-01-SUMMARY.md`
</output>
