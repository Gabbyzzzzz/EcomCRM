---
phase: 06-dashboard-and-customer-ui
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/customers/route.ts
  - src/app/(dashboard)/customers/page.tsx
  - src/components/customer-filters.tsx
autonomous: true

must_haves:
  truths:
    - "Customer list page shows paginated rows of customers from the database"
    - "Filtering by segment narrows the customer list without a full page reload"
    - "Free-text search by name or email narrows the customer list without a full page reload"
    - "Pagination controls allow navigating between pages of results"
    - "Each customer row shows name, email, segment, total spent, order count, and last order date"
  artifacts:
    - path: "src/app/api/customers/route.ts"
      provides: "GET endpoint for paginated, filtered customer list"
      exports: ["GET"]
    - path: "src/app/(dashboard)/customers/page.tsx"
      provides: "Customer list page"
      contains: "CustomersPage"
    - path: "src/components/customer-filters.tsx"
      provides: "Client Component with search input and segment filter"
      contains: "CustomerFilters"
  key_links:
    - from: "src/components/customer-filters.tsx"
      to: "src/app/api/customers/route.ts"
      via: "fetch with query params"
      pattern: "fetch.*api/customers"
    - from: "src/app/(dashboard)/customers/page.tsx"
      to: "src/components/customer-filters.tsx"
      via: "client component import"
      pattern: "CustomerFilters"
---

<objective>
Build the customer list page with server-side pagination, segment filtering, and free-text search — results update dynamically without full page reloads.

Purpose: The customer list is the core CRM view — users need to quickly find and browse customers by segment or name/email.
Output: A working `/customers` page with API-backed search, filter, and pagination.
</objective>

<execution_context>
@/Users/zhangjiabei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zhangjiabei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/db/schema.ts
@src/lib/db/queries.ts
@src/lib/env.ts
@src/app/(dashboard)/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GET /api/customers endpoint with pagination, search, and segment filter</name>
  <files>src/app/api/customers/route.ts</files>
  <action>
Create a Next.js App Router API route at `src/app/api/customers/route.ts` that handles GET requests with query parameters for pagination, search, and segment filtering.

**Query parameters (validated with Zod):**
- `page`: number, default 1, min 1
- `limit`: number, default 20, min 1, max 100
- `search`: string, optional — matches against customer name OR email (case-insensitive)
- `segment`: string, optional — one of the 7 segment values or empty string for "all"

**Zod schema:**
```typescript
const querySchema = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  search: z.string().optional().default(''),
  segment: z.enum(['champion', 'loyal', 'potential', 'new', 'at_risk', 'hibernating', 'lost', '']).optional().default(''),
})
```

**Implementation:**
- Import `db` from `@/lib/db`, schema tables from `@/lib/db/schema`, `env` from `@/lib/env`.
- Derive `shopId` from `new URL(env.SHOPIFY_STORE_URL).hostname`.
- Build WHERE conditions array:
  - Always: `eq(customers.shopId, shopId)` AND `isNull(customers.deletedAt)`
  - If segment is non-empty: `eq(customers.segment, segment)`
  - If search is non-empty: `or(ilike(customers.name, '%search%'), ilike(customers.email, '%search%'))`. Import `ilike` from 'drizzle-orm'.
- Use `and(...conditions)` to combine.
- Execute two queries:
  1. COUNT query: `db.select({ count: sql<number>\`count(*)\` }).from(customers).where(...)` — returns total matching rows
  2. Data query: `db.select().from(customers).where(...).orderBy(desc(customers.createdAt)).limit(limit).offset((page - 1) * limit)`
- Return JSON:
```typescript
{
  customers: Array<{ id, name, email, segment, totalSpent, orderCount, avgOrderValue, lastOrderAt, tags, rfmR, rfmF, rfmM }>,
  pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
}
```
- On Zod validation failure, return 400 with `{ error: string }`.
- Wrap in try/catch, return 500 on unexpected errors.

**Important:** Use `ilike` from drizzle-orm for case-insensitive search. The pattern is `ilike(column, '%text%')` — drizzle-orm exports it.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Test: `curl 'http://localhost:3000/api/customers?page=1&limit=5'` returns JSON with customers array and pagination object.</verify>
  <done>GET /api/customers returns paginated, filtered customer data with correct pagination metadata</done>
</task>

<task type="auto">
  <name>Task 2: Build customer list page with interactive filters and pagination</name>
  <files>src/app/(dashboard)/customers/page.tsx, src/components/customer-filters.tsx</files>
  <action>
Create the customer list page. The page itself is a Server Component that renders a Client Component for interactive filtering.

**src/components/customer-filters.tsx** — `CustomerFilters` (Client Component)

`'use client'` at top. This component owns the state and renders the full customer table with filters.

**Props:** `{ initialData: { customers: CustomerRow[]; pagination: Pagination } }` where types are defined locally in the file.

**State:**
- `search`: string (debounced input)
- `segment`: string (select value)
- `page`: number
- `data`: the fetched customer + pagination response
- `loading`: boolean

**Behavior:**
- On mount, use initialData from server-side fetch (no flash of empty content).
- When search, segment, or page changes, fetch from `/api/customers?page=X&limit=20&search=Y&segment=Z` and update `data`.
- Debounce search input by 300ms using a simple `useRef` + `setTimeout` pattern (no external debounce library).
- Reset page to 1 when search or segment changes.

**UI layout:**
1. **Filter bar** — flex row with:
   - Text input: `<input>` with placeholder "Search by name or email...", Tailwind classes for consistent styling (`rounded-md border bg-background px-3 py-2 text-sm`), `onChange` updates search state.
   - Segment select: `<select>` with options for "All Segments" + 7 segment values. Styled similarly.
   - Loading indicator: small spinner or "Loading..." text when `loading` is true.

2. **Customer table** — HTML table with Tailwind classes matching the automations page pattern:
   - `<div className="rounded-lg border bg-card overflow-hidden">`
   - Columns: Name, Email, Segment (colored badge), Total Spent, Orders, Last Order
   - Name column is a `<Link>` to `/customers/${customer.id}` (import Link from next/link)
   - Segment badge: colored span matching segment colors (champion=green, loyal=blue, potential=purple, new=cyan, at_risk=yellow, hibernating=orange, lost=red)
   - Total Spent: formatted as `$X,XXX.XX` — parse string, use toLocaleString with currency formatting
   - Last Order: formatted as relative date or short date (e.g., "Jan 15, 2026")
   - Empty state: "No customers found" message

3. **Pagination controls** — flex row at bottom:
   - "Showing X-Y of Z customers" text
   - Previous / Next buttons (disabled when on first/last page)
   - Page number display: "Page X of Y"
   - Use `<button>` elements with appropriate disabled states and Tailwind styling

**src/app/(dashboard)/customers/page.tsx** — Server Component

```typescript
export const metadata = { title: 'Customers | EcomCRM' }
```

- Import `env`, derive `shopId`.
- Fetch initial customer data server-side: call `db.select()` directly (same logic as the API route, first page, no filters). OR use a query function. For simplicity, import db and schema directly and run the initial query (page 1, limit 20, no filters).
- Pass data as `initialData` prop to `<CustomerFilters>`.
- Wrap in the standard page layout:
  ```tsx
  <div className="flex flex-col gap-6">
    <div>
      <h1>Customers</h1>
      <p>Browse and search your customer database</p>
    </div>
    <CustomerFilters initialData={initialData} />
  </div>
  ```

**Important patterns:**
- Server Component fetches initial data, Client Component handles subsequent fetches.
- The API route and initial server-side query should produce the same shape of data.
- All money formatting uses string parsing, never parseFloat on Decimal values — use `Number(totalSpent).toLocaleString('en-US', { style: 'currency', currency: 'USD' })` which is acceptable for display (not arithmetic).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Visit `/customers` — the page shows a table of customers (or empty state), search input filters results, segment dropdown filters results, pagination buttons navigate between pages.</verify>
  <done>Customer list page at /customers shows paginated customers with working search, segment filter, and pagination controls — all without full page reloads</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. GET /api/customers returns proper JSON with pagination metadata
3. GET /api/customers?search=john returns only customers matching "john" in name or email
4. GET /api/customers?segment=champion returns only champion customers
5. Customer list page loads with initial data from the server
6. Typing in search box triggers API fetch after debounce and updates the table
7. Selecting a segment from the dropdown updates the table
8. Pagination controls navigate between pages
9. Each customer name links to /customers/[id]
</verification>

<success_criteria>
- Customer list page loads at /customers with paginated data
- Search filters by name or email (case-insensitive, debounced)
- Segment filter narrows to a specific segment
- Pagination shows correct page counts and navigates correctly
- All data comes from the API route, validated with Zod
- TypeScript strict — no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard-and-customer-ui/06-02-SUMMARY.md`
</output>
